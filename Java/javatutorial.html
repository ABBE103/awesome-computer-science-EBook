<html lang="en-US"><head>

<title>
Brewing Java: A Tutorial 
</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="This is an introductory tutorialfor Java 1.0.">
<script language="javascript">
/* Only sunsites are allowed to mirror this page and then
only with explicit, prior permission. For details,
send email to elharo@metalab.unc.edu */
if (location.protocol.toLowerCase().indexOf("file") != 0 ) { 
  if (0 > location.host.toLowerCase().indexOf("cafeaulait.org") && 0 > location.host.toLowerCase().indexOf("sunsite") && 0 > location.host.toLowerCase().indexOf("ibiblio.org")) {
    location.href="http://www.cafeaulait.org/javatutorial.html";
  }
}
</script>
</head><body text="#000000" bgcolor="#ffffff">

<h1><a name="xtocid226300">Brewing Java: A Tutorial</a></h1>

<p>
Copyright 1995-1998, 2000-2002, 2004-2006 Elliotte Rusty Harold<br>
elharo@metalab.unc.edu<br>
Last-modified: 2005/07/19<br>
URL: http://www.cafeaulait.org/javatutorial.html</p>

<p>This tutorial has grown into a book called <cite>The Java Developer's Resource</cite>,
available now from Prentice Hall.  It's 
now out of print, but the <a href="http://www.cafeaulait.org/books/jdr/examples/">examples</a> and 
<a href="http://www.cafeaulait.org/books/jdr/exercises/">exercises</a> from that
book are also online here and may be of use. For more details about the JDR 
including the plans for a second edition see the 
<a href="http://www.cafeaulait.org/books/jdr/">JDR</a> page.</p>

<dl>
<dt><i>June 3, 2006</i></dt>
<dd>
Minor corrections on array dimensions</dd><dt><i>July 19, 2005</i></dt>
<dd>
Improve naming conventions in examples
</dd>

<dt><i>June 26, 2004</i></dt>
<dd>
Fix a typo and 
make some efforts (incomplete) toward well-formedness
</dd>


<dt><i>January 2, 2002</i></dt>
<dd>
Fix a typo and URLs
</dd>

<dt><i>February 8, 2001</i>
</dt><dd>
Minor bug fix
<p>
</p></dd><dt><i>January 6, 2001</i>
</dt><dd>
Some minor changes about = and :=
<p>
</p></dd><dt><i>May 23, 2000</i>
</dt><dd>
Fixed a few typos.
<p>
</p></dd><dt><i>April 23, 2000</i>
</dt><dd>
Fixed a few bugs.
<p>
</p></dd><dt><i>September 7, 1998</i>
</dt><dd>
Fixed a few typos
<p>
</p></dd><dt><i>June 23, 1998</i>
</dt><dd>
Very minor corrections and updates
<p>
</p></dd><dt><i>April 8, 1997</i>
</dt><dd>
This tutorial covers Java 1.0. I've also posted <a href="http://www.cafeaulait.org/course/index.html">several hundred pages of lecture notes</a>
from an Introduction to Java Programming course I'm teaching at Polytechnic University.
These notes cover Java 1.1 extensively, and cover many more topics than
are discussed here.<p>
</p><p>
</p></dd><dt><i>March 3, 1997</i>
</dt><dd>
I've fixed a number of typos.<p>

</p></dd><dt><i>November 13, 1996</i>
</dt><dd>
I've improved the treatment of recursion, expanded and updated
the installation and getting started instructions, fixed a bug in the Mondrian programs,
and cleaned up some other parts.
<p></p>

</dd><dt><i>September 20, 1996</i>
</dt><dd>
I fixed a bug in the Arg method of the complex class.  Arguments in
all quadrants are now handled properly.  I've also fixed a few other minor bugs in various
programs.
<p></p>

</dd><dt><i>March 26, 1996</i>
</dt><dd>
<p>The RAM config program, typewriter applet, Bozo sort algorithm and 
Java doodle applet are finally included.</p>

</dd><dt><i>March 25, 1996</i>
</dt><dd>
I recently completed my first book which grew out of this tutorial. 
It should be out in a few months. This file is
mostly just a rough draft for some sections of that book. 
The book will be much improved over the very rough material
you see here. If you don't like this page, you may still
like the book.  If you do like this page, you should love
the book.<p></p>

<p>I'm now left in something of a quandary.  How should I best update
this tutorial? On the one hand it would be easiest to just slap the
400 pages I wrote for the book onto the web. However that would make
my publisher very unhappy.  On the other hand I don't feel like
duplicating all my work for the book.</p>

<p>What I've decided to do is to try and clean this tutorial up by
fixing the various mistakes, but not to add much new material to it.
 For instance the last fix to the ComplexNumber class broke
multiplication. It is now working again. I've also fixed a lot of
other random mistakes.  Finally you'll notice that almost all the
unwritten sections have been deleted. At this point if something's
in the table of contents, then it's probably actually here.
</p>

<p>Don't despair, though. I'm going to be writing a 
series of shorter articles on various topics that I either didn't cover
in the book, or don't think I covered as well as I could have. Planned topics
include</p>

<p></p><ul>
<li>Why Java is different from C++
</li><li>An Introduction to classes through complex numbers
</li><li>Linked lists
</li><li>Sparse arrays
</li><li>Working with Strings
</li><li>Java Tokens
</li><li>Java Data types
</li><li>Bitwise operators
</li><li>Calling Native Code
</li><li>Inf, NaN and all that: IEEE 754 arithmetic
</li><li>Images and the Mandelbrot Set
</li></ul>
<p>
Furthermore the book includes a substantial number of exercises. However it does not include answers.
I am going to be posting those<a href="http://www.cafeaulait.org/exercises/index.html"> exercises here</a> along with detailed explanations
and answers.  In this way I hope to fill out some more  topics than I would have time to
do in a straight tutorial fashion.</p>

<p>Finally I will be putting most of the <a href="http://www.cafeaulait.org/examples/index.html">source code from the book </a>online as well.
This will provide a series of useful examples.</p>

<p>Thus there will be a lot more new tutorial here. However this tutorial is mostly complete.
There's certainly more it could cover, but I just decided I didn't want to 
write the same book twice.</p>

</dd><dt><i>February 7, 1996</i>
</dt><dd>
<p>Fixed some errors in the ComplexNumber class. DivideBy now works and toString()
gives more aesthetic results when the imaginary part of a number is negative.
</p></dd>
<dt><i>January 25, 1996</i>
</dt><dd>
<p>Polished up some of the EventTutor applets.  Lesson of the day: You have to add your components to your layout.</p>
</dd>
<dt><i>January 24, 1996</i>
</dt><dd>
<p>Finished the Middle Third Applet.  Lesson of the day: Casting is <strong>not</strong>
the same as rounding.</p></dd>

<dt><i>January 18, 1996</i>
</dt><dd><p>
Fixed assorted long standing errors.
</p></dd>

<dt><i>January 16, 1996</i></dt><dd>
 <ul>
<li>Substantially improved Complex number class and examples.
</li><li>Almost all code and most text is now beta compliant
</li><li>Added change history.
</li></ul>
 </dd></dl>

<p>This is a Java tutorial in progress.  A <a href="http://www.cafeaulait.org/javafaq.html">Java FAQ list</a> is being developed as
simultaneously as time permits.</p>

<p>Yes, I plan to split this file into smaller chunks that are
easier for browsers to digest.  However right now this is an
 early development version of this material, and ease of
writing and maintenance leads me to want to keep this file
in one piece.  When the outline settles down I will break it
up. </p>

<p>It isn't all here yet, but I hope to fill this out quickly.
The chapter on basic Java syntax is reaching completion. I
will update this as time permits.  If you find any mistakes,
please do inform me.</p>

<p>Comments you might have on the structure, organization or
contents of this document are appreciated. Although a lot
remains to be fleshed out, the basic structure is as
follows:</p>

<p>Part 1 is a brief introduction to what Java is, why it's
cool and what you need to use it.</p>

<p>Part 2 is a tutorial introduction to Java that just covers
what you need to know to start programming command line applications
in Java. This is an introduction to the basic syntax of the language.
It skims over many details and completely omits little used
features like bit-shift operators.  This section is fairly complete.</p>

<p>Part 3  covers the basics of writing applets in Java.</p>

<p>Part 4 introduces you to objects and classes.</p>

<h2><a name="xtocid18141">Table of Contents</a></h2>


<ul>
<li><a href="#xtocid5001"><b>Part 1: Why Java's Cool</b></a>
<ul>
<li><a href="#xtocid12612"><i>Installing Java</i></a>
<ul>
<li><a href="#xtocid5003">Windows Installation Instructions</a>
</li><li><a href="#xtocid5004">Unix Installation Instructions</a>
</li></ul>
</li><li><a href="#xtocid5005"><i>Running Your First Applet</i></a>
<ul>
<li><a href="#xtocid5008">Applets in Netscape</a>
</li></ul>
</li></ul>
</li><li><a href="#xtocid90007"><b>Part 2:The Syntax</b></a>
<ul>
<li><a href="#xtocid45973"><i>Hello World: The Application</i></a>
<ul>
<li><a href="#xtocid181413">Examining Hello World</a>
</li><li><a href="#xtocid45974">Braces and Blocks</a>
</li><li><a href="#xtocid181415">Comments</a>
</li><li><a href="#xtocid45975">Data and Variables</a>
</li><li><a href="#xtocid190364">Command Line Arguments</a>
</li><li><a href="#xtocid190365">If</a>
</li><li><a href="#xtocid226309">Else</a>
</li><li><a href="#xtocid45976">Variables and Arithmetic Expressions</a>
</li></ul>
</li><li><a href="#xtocid2801921"><i>Classes and Objects: A First Look</i></a>
<ul>
<li><a href="#xtocid181416">Interfaces</a>
</li></ul>
</li><li><a href="#xtocid190367"><i>FahrToCelsius</i></a>
<ul>
<li><a href="#xtocid45977">Floating Point Variables</a>
</li></ul>
</li><li><a href="#xtocid45978"><i>The For Statement</i></a>
</li><li><a href="#xtocid45979"><i>Assignment, Increment and Decrement Operators</i></a>
</li><li><a href="#xtocid459713"><i>Methods</i></a>
<ul>
<li><a href="#xtocid1903615">Recursive Methods</a>
</li></ul>
</li><li><a href="#xtocid459714"><i>Arrays</i></a>
<ul>
<li><a href="#xtocid499429">Creating Arrays</a>
</li><li><a href="#xtocid499430">Counting Digits</a>
</li><li><a href="#xtocid459715">Two Dimensional Arrays</a>
</li><li><a href="#xtocid2801933">Multidimensional Arrays</a>
</li><li><a href="#xtocid2801934">Unbalanced Arrays</a>
</li><li><a href="#xtocid2801935">Searching</a>
</li><li><a href="#xtocid2801936">Sorting</a>
</li></ul>
</li><li><a href="#xtocid181428"><i>Catching Exceptions</i></a>
</li><li><a href="#xtocid459717"><i>File I/O and Streams</i></a>
<ul>
<li><a href="#xtocid69323">Interactively communicating with the user</a>
</li><li><a href="#xtocid181431">Reading Numbers</a>
</li><li><a href="#xtocid181432">Reading Formatted Data</a>
</li><li><a href="#xtocid69324">Writing a text file</a>
</li><li><a href="#xtocid69325">Reading a text file</a>
</li></ul>
</li><li><a href="#xtocid459718"><i>Summing Up</i></a>
</li></ul>
</li><li><a href="#xtocid459719"><b>Part 3: Applets</b></a>
<ul>
<li><a href="#xtocid459720"><i>Hello World: The Applet</i></a>
<ul>
<li><a href="#xtocid459721">Examining the Hello World Applet</a>
</li></ul>
</li><li><a href="#xtocid459722"><i>The APPLET HTML Tag</i></a>
<ul>
<li><a href="#xtocid1903625">Passing Parameters to Applets</a>
</li></ul>
</li><li><a href="#xtocid459723"><i>Events and Applets</i></a>
<ul>
<li><a href="#xtocid459724">Event Tutor Applet</a>
</li><li><a href="#xtocid558854">Making a List</a>
</li><li><a href="#xtocid2801953">The Events</a>
</li></ul>
</li><li><a href="#xtocid126135"><i>Drawing Text</i></a>
</li><li><a href="#xtocid459725"><i>Drawing Graphics: Lines, Circles, Rectangles and Colors</i></a>
<ul>
<li><a href="#xtocid459726">Drawing Rectangles</a>
</li><li><a href="#xtocid459727">Drawing Lines</a>
</li></ul>
</li><li><a href="#xtocid459732"><i>Taking Action: Threads</i></a>
<ul>
<li><a href="#xtocid459733">Bozo Sort</a>
</li></ul>
</li><li><a href="#xtocid459734"><i>Interaction: Mouse and Keyboard Input</i></a>
<ul>
<li><a href="#xtocid126145">Mouse Input: Java Doodle</a>
</li><li><a href="#xtocid126146">Keyboard Input: TypeWriter</a>
</li></ul>
</li></ul>
</li><li><a href="#xtocid459735"><b>Part 4:  Objects, Classes, Methods, and Interfaces</b></a>
<ul>
<li><a href="#xtocid499464"><i>What is Object Oriented Programming?</i></a>
<ul>
<li><a href="#xtocid2801972">The History of Programming</a>
</li><li><a href="#xtocid499465">Classes and Objects</a>
</li><li><a href="#xtocid2801974">Methods</a>
</li><li><a href="#xtocid2801977">Some Advocacy</a>
</li></ul>
</li><li><a href="#xtocid900031"><i>A Non-Trivial Examples: Complex Numbers</i></a>
<ul>
<li><a href="#xtocid2801984">toString Methods</a>
</li><li><a href="#xtocid2801985">Polymorphism</a>
</li></ul>
</li><li><a href="#xtocid1903648"><i>Scope: Calling the Complex Class From External Classes</i></a>
</li><li><a href="#xtocid1903649"><i>The Mandelbrot Set</i></a>
</li></ul>
</li><li><a href="#xtocid459773"><b>Acknowledgements</b></a>
</li></ul>

<h2><a name="xtocid5001">Part 1: Why Java's Cool</a></h2>

<p>Java has caused more excitement 
than any development on the Internet since Mosaic.
Everyone, it seems, is talking about it.  Unfortunately very few people seem to know anything
about it.  This tutorial is designed to change that.</p>

<p>People are excited about 
Java because of what it lets them do.  Java was the first way to
include inline sound and animation in a web page. 
Java also lets users 
interact with a web page.  Instead of just reading it and perhaps filling
out a form, users can now play games, calculate spreadsheets, chat
in realtime, get continuously updated data and much, much more.</p>

<p>Here are just a few of the many things Java can do for a web page:</p>
<ul>
<li>Inline sounds that play in realtime whenever a user loads a page
</li><li>Music that plays in the background on a page
</li><li>Cartoon style animations
</li><li>Realtime video
</li><li>Multiplayer interactive games
</li></ul>

<p>
However Java is more than just a web browser with special features.  
All of these features can be integrated into browsers in other ways.
Although HotJava was the first browser to include inline sound and animation,
Microsoft's Internet Explorer 2.0 and Netscape Navigator 2.0 support these features
in several different ways.  What makes Java special?</p>

<p>Java is a programming language for distributed applications.  
It doesn't just allow you to add 
new types of content to your 
pages like Netscape and Internet Explorer do.  Rather it lets
you add both the content and the code necessary to interact with that content.
You no longer need to wait for the next release of a browser 
that supports your 
preferred image format or special game protocol.  
With Java you send browsers both
the content and the program necessary to view this content at the same time!</p>

<p>Let's think about what this means for a minute.  Previously you had to wait for all the 
 companies that make the web browsers your readers use to update their browsers before 
 you could use a new content type.  Then you had to hope that all your readers actually did
 update their browsers.  Java compatibility is a feature that any browser can implement
 and by so doing implement every feature!</p>
 
 <p>For instance let's say you 
 want to use EPS files on your Web site.  Previously you had to wait 
 until at least one web browser implemented EPS support.  
 Now you don't wait.  Instead you can write
your own code to view EPS files and send it to any client that requests your page at the same time
 they request the EPS file.</p>
 
<p> Or suppose you want people to be able to search your electronic card catalog.  However
 the card catalog database exists on a mainframe system that doesn't speak HTTP.  Before
 Java you could hope that some browser implemented your proprietary card catalog protocol;
 (fat chance) or you could try to program some intermediate cgi-bin on a UNIX box that
 can speak HTTP and talk to the card catalog, not an easy task.  With Java when a client
 wants to talk to your card catalog you can send them the code they need to do so.  You don't
 have to try to force things through an httpd server on port 80 that were never meant to
 go through it.</p>

<p>If that were all Java was, it would still be more interesting than a <code>&lt;marquee&gt;</code>
or <code>&lt;frame&gt;</code> tag in some new browser beta.  But there's a lot more.
Java is platform independent.  A Java program can run equally well on any architecture that
has a Java enabled browser.  With the release of Netscape Navigator 2.0 that includes
Windows 95, Windows NT, the MacOS, Sun Solaris, Sun OS 4.1.3, SGI IRIX,
OSF/1, HP-UX with more to come.
But wait.  There's more!</p>

<p>Java isn't just for web sites.  Java is a programming language that lets you do 
almost anything
you can do with a traditional programming langauge like Fortran or C++. However Java has learned
from the mistakes of its predecessors. It is considerably cleaner and easier to use than 
those languages.</p>

<p>As a language Java is</p>

<p></p><dl>
<dt>Simple
</dt><dd>
Java has the bare bones functionality needed to implement its rich feature set.
It does not add lots of syntactic sugar or unnecessary features.<p>
</p></dd><dt>Object-Oriented
</dt><dd>
Almost everything in Java is either a class, a method or an object. Only the most basic
primitive operations and data types (int, for, while, etc.) are at a sub-object level.<p>
</p></dd><dt>Platform Independent
</dt><dd>
Java programs are compiled to a byte code format that can be read and run by interpreters
on many platforms including Windows 95, Windows NT, and Solaris 2.3 and later.<p>
</p></dd><dt>Safe
</dt><dd>
Java code can be executed in an environment that prohibits it from 
introducing viruses, deleting or modifying files, or otherwise 
performing data destroying and computer crashing operations.<p>
</p></dd><dt>High Performance
</dt><dd>
 Java can be compiled on the fly with a Just-In-Time compiler (JIT)
 to code that rivals C++ in speed.<p>
</p></dd><dt>Multi-Threaded
</dt><dd>
Java is inherently multi-threaded.  A single Java program can have many different things
processing independently and continuously.<p>
</p></dd></dl>

<h3><a name="xtocid12612">Installing Java</a></h3>

<p>As of this writing Java is not a fully developed commercial product.  
Versions of Java at varying stages of completion are available 
from Sun for Windows 95 and  Windows NT for X86, Solaris 2.3 to 2.5,
and MacOS 7.5.
At the present time there are no versions of Java available for MIPS, Alpha or 
PowerPC based NT, Windows 3.1, or the Amiga.</p>

<p> 
 <a href="http://www.borland.com/">Borland</a> is also
working a Java development environment to be released in the
first half of 1996.  Various third-party efforts are under
way to port Java to other platforms including the
Amiga, Windows 3.1, OS/2 and others.</p>

<p>The basic Java environment consists of a web browser that
can play Java applets, a Java compiler to turn to Java
source code into byte code, and a Java interpreter to run
Java programs. These are the three key components of a Java
environment.  You'll also need a text editor like Brief or
BBEdit.  Other tools like a debugger, a visual development
environment, documentation and a class browser are also nice
but aren't absolutely necessary.</p>

<p>Note that it isn't necessary to get all three of these from
the same source.  For instance <a href="http://home.netscape.com/">Netscape</a> is committed
to providing a Java-enabled web browser.  However it will
only provide a Java compiler with the next version of its
server products.</p>

<p>Sun has made the Java Developers Kit available for its supported platforms.  
It includes an applet viewer that will let
you view and test your applets. The JDK
also includes the javac compiler, the java interpreter, the
javaprof profiler, the javah header file generator (for
integrating C into your Java code), the Java debugger and
limited documentation. However most of the documentation for
the API and the class library is on Sun's web site. </p>

<p>You can ftp the programs from the following sites:</p>

<p></p><ul>
<li>USA
<ul>
<li><a href="ftp://ftp.javasoft.com/pub/">ftp://ftp.javasoft.com/pub/</a>
</li><li><a href="ftp://www.blackdown.org/pub/Java/pub/">ftp://www.blackdown.org/pub/Java/pub/</a>
</li><li><a href="ftp://ftp.science.wayne.edu/pub/java/">ftp://ftp.science.wayne.edu/pub/java/</a>
</li><li><a href="ftp://metalab.unc.edu/pub/languages/java/">ftp://metalab.unc.edu/pub/languages/</a>
</li><li><a href="ftp://java.dnx.com/pub/JDK-beta-win32-x86.exe">ftp://java.dnx.com/pub/</a>
</li></ul>
</li><li>Germany: <a href="ftp://sunsite.informatik.rwth-aachen.de/pub/mirror/java.sun.com/">ftp://sunsite.informatik.rwth-aachen.de/pub/mirror/java.sun.com/JDK-beta-win32-x86.exe</a>
</li><li>Korea: <a href="ftp://ftp.kaist.ac.kr/pub/java/">ftp://ftp.kaist.ac.kr/pub/java/e</a>
</li><li>China: <a href="ftp://math01.math.ac.cn/pub/sunsite/">ftp://math01.math.ac.cn/pub/sunsite</a>
</li><li>Japan: <a href="ftp://ftp.glocom.ac.jp/mirror/java.sun.com/">ftp://ftp.glocom.ac.jp/mirror/java.sun.com/</a>
</li><li>Sweden: <a href="ftp://ftp.luth.se/pub/infosystems/www/hotjava/pub/">ftp://ftp.luth.se/pub/infosystems/www/hotjava/pub/</a>
</li><li>Singapore: <a href="ftp://ftp.iss.nus.sg/pub/java/">ftp://ftp.iss.nus.sg/pub/java/</a>
</li><li>United Kingdom: <a href="ftp://sunsite.doc.ic.ac.uk/packages/java/">ftp://sunsite.doc.ic.ac.uk/packages/java/</a>
</li></ul>

<h4>Macintosh Installation Instructions</h4>
<p>The file you get will be a self-extracting archive called something
like JDK-1_0_2-MacOS.sea.bin. If you use Fetch or Anarchie to
download it will be automatically converted into the self-extracting
JDK-1_0_2-MacOS.sea. Double-click it to extract it and the
double-click the resulting installer JDK-1_0_2-MacOS. It will prompt
you for a location to put it on your hard disk. Put it wherever is
convenient.</p>

<p>It may be helpful to make aliases of the Applet Viewer,
the Java Compiler and the Java Runner and put them on your desktop
for ease of dragging and dropping later, especially if you have a
large monitor.</p>

<h4><a name="xtocid5003">Windows Installation Instructions</a></h4>

<p>The Windows X86 release is a self extracting archive.  You
will need about six megabytes of free disk space to install
the JDK. Execute the file by double-clicking on it in the
File Manager or by selecting Run... from the Program
Manager's File menu and typing the path to the file. This
will unpack the archive. The full path is unimportant, but for
simplicity's sake I am going to assume you installed it from
the root of your C: drive. If this is the case the 
files will live in C:\java.  If you unpacked it somewhere else just replace
C:\ by the full path to the java directory in what
follows.</p>

<p>You will need to add C:\java\bin directory to your PATH
environment variable</p>

<p>In addition to the java files, the archive includes two common DLL's:
</p><ul>
<li>MSVCRT20.DLL
</li><li>MFC30.DLL
</li></ul>
These two files will be installed in your java directory.  
If you do not already have copies of these two files on your
system, (There's a very good chance you do, probably in your
system directory.) copy them into the C:\java\bin directory.
If you do have these two files already, just delete these
extra copies. <p></p>

<h4><a name="xtocid5004">Unix Installation Instructions</a></h4>

<p>If you're on a shared system at a university or an Internet service
provider, there's a good chance Java is already installed. Ask your
local support staff how to access it. Otherwise follow these
instructions.</p>

<p> The Unix release is a compressed tar file. You will
need about nine megabytes of disk space to uncompress and untar the
JDK. Double that would be very helpful. You do this with the
commands:</p><p>
</p><pre><samp>% uncompress JDK-1_0_2-solaris2-sparc.tar.Z
% tar xvf JDK-1_0_2-solaris2-sparc.tar
</samp></pre>
<p>The exact file name may be a little different if you�re retrieving
the release for a different platform such as Irix or if the version
is different. You can untar it in your home directory, or, if you
have root privileges, in some convenient place like /usr/local where
all users can have access to the files. However root privileges are
not necessary to install or run Java. Untarring the file creates all
necessary directories and sub-directories. The exact path is
unimportant, but for simplicity's sake this book assumes it�s
installed it in /usr/local. If a sysop already installed it, this is
probably where it lives. (Under Solaris it's also possible the sysop
put it into /opt.) If this is the case the files live in
/usr/local/java. If you unpacked it somewhere else, just replace
/usr/local by the full path to the java directory in what follows.
If you installed it in your home directory, you can use ~/java and
~/hotjava instead of a full path.</p><p>
You now need to add /usr/local/java/bin directory to your PATH
environment variable. You use one of the following commands
depending on your shell.</p><p>
</p><pre>csh, tcsh: 
<code>	% set path=($PATH /usr/local/java/bin)
</code>sh: 
<code>	% PATH=($PATH /usr/local/java/bin); export $PATH
</code></pre>

<p>You should also add these lines to the end of your .profile and
.cshrc files so you won't have to do this every time you login. Now
you're ready to run some applets.</p>

<h3><a name="xtocid5005">Running Your First Applet</a></h3>

<h4>Unix Instructions</h4>
<p>Start the Applet Viewer by doing the following: </p><p>
</p><ol start="1" type="1">
	<li>	Open a command line prompt, and cd to one of the directories in /usr/local/java/demo, for example
<pre><code>% cd /usr/local/java/demo/TicTacToe 
</code></pre>	</li><li>	Run the appletviewer on the html file:
<pre><code>% appletviewer example1.html </code></pre>
	</li><li>	Play Tic-Tac-Toe!  The algorithm was deliberately broken so it is possible to win.  
</li></ol>
<h4>Macintosh Instructions</h4>
<ol start="1" type="1">
	<li> Start the Applet Viewer by double-clicking it.
	</li><li> Select Open... from the File menu and navigate into the java folder, then the Sample Applets folder, then the TicTacToe folder.
	</li><li> Select the file example1.html and click on the Open button. 
Alternately you can drag and drop this file onto the Applet Viewer. 
	</li><li> Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win. 
</li></ol>
<h4>Windows Instructions</h4>
Start the Applet Viewer by doing the following: <p>
</p><ol start="1" type="1">
	<li>	Open a DOS window, and cd to one of the directories in C:\JAVA\DEMO, for example
<pre><code>C:&lt; cd C:\JAVA\DEMO\TicTacToe 
</code></pre>	</li><li>	Run the appletviewer on the html file:
<pre><code>C:&lt; appletviewer example1.htm </code></pre>
	</li><li>	Play Tic-Tac-Toe!  The algorithm was deliberately broken so it is possible to win.
</li></ol>

<h6>Hot Tip: Getting Rid of that Annoying License Dialog Box</h6>

<p>Do you know the annoying dialog box I'm talking about?  I
bet you do.  It's the one that comes up every time you
launch the applet viewer to make you agree to Sun's license. 
Do you want to get rid of it?  If so make a directory called
<i>.hotjava</i> in your java/bin directory.  You won't see
it again.</p>

<h4><a name="xtocid5008">Applets in Netscape</a></h4>

<p>Netscape 3.0 will run Java applets on most platforms except
Windows 3.1. Netscape has a <a href="http://home.netscape.com/comprod/products/navigator/version_2.0/java_applets/index.html">Java
Demo Page</a> with links to various applets that will mostly
run.  However do not be surprised if an applet fails to work
properly in Netscape.</p>

<h2><a name="xtocid90007">Part 2:The Syntax</a></h2>
<h3><a name="xtocid45973">Hello World: The Application</a></h3>

<p>At least since the first edition of <person>Kernighan</person> and 
<person>Ritchie's</person> <cite>The C Programming Language</cite> it's been customary  
to begin programming tutorials and classes
with the "Hello World"
program, a program that prints the string "Hello World" to the
display.  Being heavily influenced by Kernighan and Ritchie and not
ones to defy tradition we begin similarly.</p>

<p>The following is the Hello World Application as written in Java.
Type it into a text file or copy it out of your web browser, and save it
as a file named <i>HelloWorld.java</i>.</p>

<pre><code>class HelloWorld {

  public static void main (String args[]) {

    System.out.println("Hello World!");

  }
  
}</code></pre>

<p>To compile this program make sure you're in the same directory HelloWorld.java is
in and
type <kbd>javac HelloWorld.java</kbd> at the command prompt.

<i>Hello World</i> is very close to the simplest program imaginable.
Although it doesn't teach very much from a programming standpoint,
it gives you a chance to learn the mechanics of writing and compiling code.
If you're like me your first effort won't compile, especially if you
typed it in from scratch rather than copying and pasting.  Here 
are a few common mistakes: </p>

<p>
</p><li> Did you put a semicolon after <code>System.out.println("Hello World")</code>?
</li><li> Did you include the closing bracket?
</li><li> Did you type everything exactly as it appears here?  In 
particular did you use the same capitalization?  Java is case sensitive.
 <code>class</code> is not the same as <code>Class</code>
for example.
</li><li>Were you in the same directory as HelloWorld.java when you typed javac HelloWorld.java?


<p>Once your program has compiled successfully, the compiler places the
executable output in a file called HelloWorld.class in the same directory
as the source code file.
You can then run the program by typing <kbd>java HelloWorld</kbd>
at the command prompt. As you probably guessed the program responds by  printing 
<samp>Hello World!</samp> on your screen.</p>

<p>Congratulations!  You've just written your first Java program!</p>

<h4><a name="xtocid181413">Examining Hello World</a></h4>

<p><i>Hello World</i> is very close to the simplest program imaginable. 
Nonetheless there's quite a lot going on in it.  Let's investigate it, 
line by line.</p>

<p>For now the initial <code>class</code> statement may be thought of as defining
the program name, in this case HelloWorld.  The compiler actually got the name for the class file from the <code>class HelloWorld</code>
 statement in the source code, not from the name of the source code 
file.  If there is more than one class in a file, then the Java
compiler will store each one in a separate .class file.  For reasons 
we'll see
 later it's advisable to give the source code file the same name as the 
main class in the file plus the .java extension.</p>

<p>The initial <code>class</code> statement is actually quite a bit more than
that since this "program" can be called not just from 
the command line but also by other parts of the same or different
programs.  We'll see more in the section on
classes and methods below.</p>

<p>The HelloWorld class contains one <dfn>method</dfn>,
the main method.  As in C the main method is where an application
begins executing.  The method is declared <dfn>public</dfn> meaning that
the method can be called from anywhere.  It is declared <dfn>static</dfn>
meaning that all instances of this class share this one method.  
(If that last sentence was about as intelligible as Linear B, don't worry.  
We'll come back to it later.)
It is declared <dfn>void</dfn> which means, as in C,
that this method does not return a value.  Finally we pass
any command line arguments to the method in an array of Strings
called <code>args</code>.  In this simple program there aren't
any command line arguments though.</p>

<p>Finally when the main method is called it does exactly one thing: print 
"Hello World" to the standard output, generally a terminal
monitor or console window of some sort.  This is accomplished by the
<code>System.out.println</code> method.  To be more precise this is accomplished
by calling the <code>println()</code> method of the static
<code>out</code> field belonging to the
<code>System</code> class; but for now we'll just treat this as one method.
</p>

<p>One final note: unlike the <code>printf</code> function in C the 
<code>System.out.println</code> method <em>does</em> append a newline at the end of its output.
There's no need to include a <code>\n</code> at the end of each string to break a line.
 </p>

<h6>Exercises</h6>

<ol>
<li>What happens if you change the name of the source code file, e.g. HelloEarth.java instead of HelloWorld.java?
</li><li>What happens if you keep the name of the source code file the 
same (HelloWorld.java) but change the class's name, e.g. class 
HelloEarth?
</li></ol>
<h4><a name="xtocid45974">Braces and Blocks</a></h4>

<p>Let's investigate the Hello World program a little more closely.  In
Java a source code file is broken up into parts separated by opening
and closing braces, i.e. the { and } characters.  Everything between
{ and } is a <dfn>block</dfn> and exists more or less independently
of everything outside of the braces. </p>

<p>Blocks are important both syntactically and logically.  Without the
braces the code wouldn't compile.  The compiler would have trouble
figuring out where one method or class ended and the next one began.
 Similarly it would be very difficult for someone else reading your
code to understand what was going on.  For that matter it would be
very difficult for you, yourself to understand what was going on. 
The braces are used to group related statements together.  In the
broadest sense everything between matching braces is executed as one
statement (though depending not necessarily everything inside the
braces is executed every time).</p>

<p>Blocks can be hierarchical. One block can contain one or more
subsidiary blocks. In this case we have one outer block that defines
the HelloWorld class. Within the HelloWorld block we have a method
block called "main".</p>

<p>In this tutorial we help to identify different blocks with
indentation.  Every time we enter a new block we indent our source
code by two spaces.  When we leave a block we deindent by two
spaces. This is a common convention in many programming languages. 
However it is not part of the language.  The code would produce
identical output if we didn't indent it.  In fact I'm sure you'll
find a few examples here where I haven't followed convention
precisely.  Indentation makes the code easier to read and
understand, but it does not change its meaning.</p>

<h4><a name="xtocid181415">Comments</a></h4>

<p>Comments can appear anywhere in a source file.  Comments are
identical to those in C and C++.  Everything between <code>/*</code>
and <code>*/</code> is ignored by the compiler and everything on a 
line after two consecutive slashes is also thrown away.  Therefore
the following program is, as far as the compiler is concerned, identical
to the first one:</p>

<pre><code>// This is the Hello World program in Java
class HelloWorld {

    public static void main (String args[]) {
      /* Now let's print the line Hello World */
      System.out.println("Hello World");
      
  }

}</code></pre>

<h4><a name="xtocid45975">Data and Variables</a></h4>
<p>Methods are only half of a Java class.  The other half is data. Consider the
following generalization of the HelloWorld program:</p>

<pre><code>// This is the Hello Rusty program in Java
class HelloRusty {

    public static void main (String args[]) {
    
      // You may feel free to replace "Rusty" with your own name
      String name = "Rusty";
      
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(name);
  }

}</code></pre>

<p>Here, rather than saying hello to a rather generic world, we allow Java to
say hello to a specific individual.  We do this by creating a <dfn>String variable</dfn>
called "name" and storing the value "Rusty" in it.  (You may, of course,
have replaced Rusty with your own name.)  Then we print out "Hello ".  Notice that
we've switched here from <code>System.out.println</code> method to the similar <code>System.out.print</code> method.  
<code>System.out.print</code> is just like <code>System.out.println</code> except that it doesn't break the line after
it's finished. Therefore when we reach the next line of code, the cursor is still located 
on the same line as the word "Hello" and we're ready to print out the name.</p>

<h4><a name="xtocid190364">Command Line Arguments</a></h4>

<p>Our Hello program still isn't very general.  We can't change the name we say hello to without 
editing and recompiling the source code.  This may be fine for the programmers, but
what if the secretaries want their computers to say Hello to them?  (I know.  This is a little far-fetched
but bear with me. I'm making a point.)</p>

<p>What we need is a way to change the name at <dfn>runtime</dfn> rather
than at compile time. (Runtime is when we type <kbd>java HelloRusty</kbd>. Compile 
time is when we type <kbd>javac HelloRusty.java</kbd>).  To do this we'll make use
of <dfn>command-line arguments</dfn>.  They allow us to type something like <kbd>Java Hello Gloria</kbd> and have the program respond with "Hello Gloria". Here's the code:</p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(args[0]);
  }

}</code></pre>

Compile this program in the javahtml directory as usual and then type <kbd>java Hello Gloria</kbd>.<p></p>

<p>This isn't very hard is it?  In fact we've even gotten rid of the name variable from the
HelloRusty program.  We're using <code>args[0]</code> instead.  <code>args</code> is what is known as an <dfn>array</dfn>. An array stores a series of values.  
The values can be Strings as in this example,
numbers, objects or any other kind of Java data type.  </p>

<p><code>args</code> is a special array that holds the command line arguments.  <code>args[0]</code> holds the first command line argument.  <code>args[1]</code> holds the second command line argument, <code>args[2]</code> holds the third command line argument and so on.</p>

<p>At this point almost everyone reading this is probably saying
"Whoa, that can't be right." However  why you're
saying  depends on your background.</p>

<p>If you've never programmed before or if you've programmed only in 
Pascal or Fortran,
you're probably wondering why the first element of the array is at 
position 0, the second at position 1, the third at position 2 instead of
 the clearly more sensible element 1 being the first element in the 
array, element 2 being the second and so on.  All I can tell you is that
this is a holdover from C where this convention almost made sense.</p>

<p>On the other hand if you're used to C you're probably upset because <code>args[0]</code> 
is the first command line argument instead of the command name.  The problem is that in Java 
it's not always clear what the command name is.  For instance in the 
above example is it java or Hello?  
On some systems where Java runs there may not even be a command line, 
the Mac for example.</p>

<p>Now you should experiment with this program a little.  What happens if instead of typing 
<kbd>java Hello Gloria</kbd> you type <kbd>java Hello Gloria and Beth</kbd>?  What if you
leave out the name entirely, i.e. <kbd>java Hello</kbd>?</p>

<p>That was interesting wasn't it?  You should have seen something very close to</p>

<p><samp>Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
  at Hello.main(C:\javahtml\Hello.java:7)</samp></p>

<p>What happened was that since we didn't give Hello any command line arguments there wasn't anything in <code>args[0]</code>.  Therefore Java kicked back this not too friendly 
error message about an "ArrayIndexOutOfBoundsException." That's a mouthful.  
We'll see one way to fix it in the next section.</p>

<h4><a name="xtocid190365">If</a></h4>

<p>All but the most trivial computer programs need to make decisions.  They need
to test some condition and operate differently based on that condition.  This is quite
common in real life.  For instance you stick your hand out the window to <i>test</i>
if it's raining.  If it is raining then you take an umbrella with you.  
If it isn't raining then you don't.</p>

<p>All programming languages have some form of an <code>if</code> statement that allows you
to test conditions.  In the previous code we should have tested whether there
actually were command line arguments before we tried to use them.</p>

<p>All arrays have lengths and we can access that length by referencing the variable <code>arrayname.length</code>.  
(Experienced Java programmers will note that this means 
that the array is an object which contains a public member variable called length.) 
We  test the length of the <code>args</code> array as follows:</p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length &gt; 0) {
        System.out.println(args[0]);
      }
  }

}</code></pre>

Compile and run this program and toss different inputs at
it.  You should note that there's no longer an
ArrayIndexOutOfBoundsException if you don't give it any
command line arguments at all.<p></p>

<p>What we did was wrap the
<code>System.out.println(args[0])</code> statement in a
conditional test, <code>if (args.length &gt; 0) { }</code>. 
The code inside the braces,
<code>System.out.println(args[0])</code>, now gets executed
if and only if the length of the args array is greater than
zero.  In Java numerical greater than and lesser than tests
are done with the &gt; and &lt; characters respectively. We
can test for a number being less than or equal to and
greater than or equal to with &lt;= and &gt;=
respectively.</p>

<p>Testing for equality is a little trickier.  We would expect
to test if two numbers were equal by using the = sign. 
However we've already used the = sign to set the value of a
variable. Therefore we need a new symbol to test for
equality.  Java borrows C's double equals sign, ==, to test
for equality.</p>

<p>It's not uncommon for even experienced programmers to write
== when they mean = or vice versa. In fact this is a very
common cause of errors in C programs. Fortunately in Java,
you are not allowed to use == and = in the same places. 
Therefore the compiler can catch your mistake and make you
fix it before you run the program.</p>

<p>All conditional statements in Java require boolean values,
and that's what the ==, &lt;, &gt;, &lt;=, and &gt;=
operators all return.  A boolean is a value that is either
true or false.  Unlike in C booleans are not the same as
ints, and ints and booleans cannot be cast back and forth.
If you need to set a boolean variable in a Java program, you
have to use the constants <code>true</code> and
<code>false</code>. <code>false</code> is not 0 and
<code>true</code> is not non-zero as in C.  Boolean values
are no more integers than are strings.</p>

<p>Experienced programmers may note that there was an
alternative method to deal with the
ArrayIndexOutOFBoundsException involving <code>try</code>
and <code>catch</code> statements.  We'll return to that
soon.</p>

<h4><a name="xtocid226309">Else</a></h4>

<p>You may have noticed a minor <dfn>cosmetic bug</dfn> in the
previous program.  A cosmetic bug is one that doesn't crash
the program or system, or produce incorrect results, but
just looks a little annoying. Cosmetic bugs are acceptable
in quick hacks you'll only use once but not in finished
code.</p>

<p>The cosmetic bug here was that if we didn't include any
command line arguments, although the program didn't crash,
it still didn't say Hello. The problem was that we only used
<code>System.out.print</code> and not
<code>System.out.println</code>. There was never any end of
line character. It was like we typed in what we wanted to
say, but never hit the return key.</p>

<p>We could fix this by putting a
<code>System.out.println("");</code> line at the
end of the main method, but then we'd have one too many
end-of-lines if the user did type in a name.  We could add
an additional if statement like so:</p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length &gt; 0) {
        System.out.println(args[0]);
      }
      if (args.length &lt;= 0) {
        System.out.println("whoever you are");
      }
  }

}</code></pre>

This corrects the bug, but the code is hard to read and
maintain. It's very easy to miss a possible case.  For
instance we might well have tested to see if
<code>args.length</code> were less than zero and left out
the more important case that <code>args.length</code> equals
zero.  What we need is an <code>else</code> statement that
will catch any result other than the one we hope for, and
luckily Java provides exactly that.  Here's the right
solution:<p></p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length &gt; 0) {
        System.out.println(args[0]);
      }
      else {
        System.out.println("whoever you are");
      }
  }

}</code></pre>

Now that Hello at least doesn't crash with an
ArrayIndexOutOfBoundsException we're still not done. 
<kbd>java Hello</kbd> works and <kbd>Java Hello Rusty</kbd>
works, but if we type <kbd>java Hello Elliotte Rusty
Harold</kbd>, Java still only prints <samp>Hello
Elliotte</samp>.  Let's fix that. <p></p>

<p>We're not just limited to two cases though.  We can combine
an <code>else</code> and an <code>if</code> to make an
<code>else if</code> and use this to test a whole range of
mutually exclusive possibilities. For instance here's a
version of the Hello program that handles up to four names
on the command line:</p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      if (args.length == 0) {
        System.out.print("whoever you are");
      }
      else if (args.length == 1) {
        System.out.println(args[0]);
      }
      else if (args.length == 2) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
      }      
      else if (args.length == 3) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
      }      
      else if (args.length == 4) {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
        System.out.print(" ");
        System.out.print(args[3]);
      }      
      else {
        System.out.print(args[0]);
        System.out.print(" ");
        System.out.print(args[1]);
        System.out.print(" ");
        System.out.print(args[2]);
        System.out.print(" ");
        System.out.print(args[3]);
        System.out.print(" and all the rest!");
       }
      System.out.println();
  }

}</code></pre>

You can see that this gets mighty complicated mighty quickly.  Once 
again no experienced Java programmer would write code like this. One of 
the things that makes this solution so unwieldy is that I've used a 
different print statement for every single variable.  However Java makes
 it very easy to print multiple items at once.  Instead of including 
just one thing in the print method's arguments we put multiple items in 
there separated by + signs. These items can include variables like <code>args[0]</code> and constant strings like <code>" and all the rest!"</code>.  For example the last else block could have been written as<p></p>

<pre><code>else {
  System.out.print(args[0] + " " + args[1] + " " + args[2] + " " + args[3] + " and all the rest!");
}</code></pre>

This syntax is simpler to read and write but would still be unwieldy 
once the number of command line arguments grew past ten or so. In the 
next section we'll see how to handle over two billion command line 
arguments in a much simpler fashion.<p></p>

<h6>Exercises</h6>
<ol>
<li>Rework the entire program to use no more than one print method in each block.<p>
</p></li><li>A truly elegant solution to this problem relies on statements that haven't been introduced yet, notably <code>for</code>.
  However there is a more elegant and space efficient solution that 
accomplishes everything we did above, does not use the + operator, and 
uses only <code>if</code>'s and a single <code>else</code>. No <code>else if</code>'s are needed.  Can you find it?<p>
</p></li></ol>

<h4><a name="xtocid45976">Variables and Arithmetic Expressions</a></h4>

We'll begin this section by finding a more elegant way to handle multiple command line arguments of an undetermined number.  
Toward this end we introduce the concept of a loop.  A loop is a section of code that is
executed repeatedly until a stopping condition is met.  A typical loop may look like:<p></p>

<pre>while there's more data {
  Read a Line of Data
  Do Something with the Data
}</pre>

This isn't working code but it does give you an idea of a very typical 
loop.  We have a test condition (Is there more data?) and something we 
want to do with if the condition is met. 
(Read a Line of Data and Do Something with the Data.) <p></p>

<p>There are many different kinds of loops in Java including <code>while</code>, <code>for</code>, and <code>do while</code> loops.
They differ primarily in the stopping conditions used.</p>

<p><code>For</code> loops typically iterate a fixed number of times and then exit.  <code>While</code> loops iterate
continuously until a particular condition is met.  You usually do not know in advance how many times a <code>while</code> loop will loop. </p>

<p>In this case we want to write a loop that will print each of the 
command line arguments in succession, starting with the first one.  We 
don't know in advance how many arguments there will be, but we can 
easily find this out before the loop starts using the <code>args.length</code>.
Therefore we will write this with a <code>for</code> loop.  Here's the code:</p>

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      int i;
    
      /* Now let's say hello */
      System.out.print("Hello ");
      for (i=0; i &lt; args.length; i = i+1) {
        System.out.print(args[i]);
        System.out.print(" ");
      }
      System.out.println();
  }

}</code></pre>


We begin the code by declaring our variables.  In this case
we have exactly one variable, the integer <code>i</code>.<p></p>

<p>Then we begin the program by saying "Hello" just
like before. </p>

<p>Next comes the <code>for</code> loop.  The loop begins by
initializing the counter variable <code>i</code> to be zero.
 This happens exactly once at the beginning of the loop. 
Programming tradition that dates back to Fortran insists
that loop indices be named <code>i</code>, <code>j</code>,
<code>k</code>, <code>l</code>, <code>m</code> and
<code>n</code> in that order. This is purely a convention
and not a feature of the Java language. However anyone who
reads your code will expect you to follow this convention. 
If you choose to violate the convention, try to give your
loop variables mnemonic names like <code>counter</code> or
<code>loop_index</code>.</p>

<p>Next is the test condition.  In this case we test that
<code>i</code> is less than the number of arguments. When
<code>i</code> becomes equal to the number of arguments,
(<code>args.length</code>) we exit the loop and go to the
first statement after the loop's closing brace.  You might
think that we should test for <code>i</code> being less than
or equal to the number of arguments; but remember that we
began counting at zero, not one.</p>

<p>Finally we have the increment step, <code>i=i+1</code>. 
This is executed at the end of each iteration of the loop. 
Without this we'd continue to loop forever since
<code>i</code> would always be less than
<code>args.length</code>. (unless, of course,
<code>args.length</code> were less than or equal to zero. 
When would this happen?).</p>

<p></p><h5>Sidebar: Why Algebra teachers hate Basic and aren't that
fond of C</h5>

The statement <code>i=i+1</code> drives algebra teachers up
the wall. It's an invalid assertion. There isn't a number in
the world for which the statement i=i+1 is
true.  In fact if you subtract i from both sides of that
equation you get the patently false statement that
<i>0&nbsp;=&nbsp;1</i>.  The trick here is that the symbol =
does not imply equality.  That is reserved for the double
equals sign, ==. In almost all programming languages
including Java a single equals sign is the assignment
operator. <p></p>

<p>The notable exceptions are Pascal (and the Pascal
derivatives Modula-2, Modula-3 and Oberon), Ada, and Eiffel 
where <code>=</code> does in
fact mean equality and where <code>:= </code>is the assignment operator. 
Math teachers are very fond of their equal sign and don't
like to see it abused. This is one reason why Pascal is
still the most popular language for teaching programming,
especially in schools where the Computer Science department
is composed mainly of math professors.</p>

<p>Needless to say math professors hate languages like Basic
where, depending on context, = can mean either assignment or
equality.</p>

<p>
</p><h6>Exercises</h6>
<ol>
<li>What happens now if we don't give the Hello program any command line arguments?
We aren't testing the number of command line arguments anymore so why isn't
an ArrayIndexOutOfBoundsException thrown?<p>
</p></li><li>For math whizzes only: I lied. In certain interpretations of certain number systems the statement <i>i = i + 1</i> does have a valid solution for <i>i</i>. What is it?<p> 
</p></li></ol>

<h3><a name="xtocid2801921">Classes and Objects: A First Look</a></h3>

Classes are the single most important feature of Java. 
Everything in Java is either a class, a part of a class, or
describes how a class behaves.  Although classes will be
covered in great detail in section four, they are so
fundamental to an understanding of Java programs that a
brief introduction is going to be given here.<p></p>

<p>All the action in Java programs takes place inside 
class blocks, in this case the HelloWorld class.  In Java almost everything
of interest is either a class itself or belongs to a class.  
Methods are defined inside the classes
they belong to.  This may be a little confusing to C++ programmers who
are used to defining all but the simplest methods outside the class block, 
but this approach is really more sensible.  C++ takes the road it does
primarily out of desire to be compatible with C, not out of good object-oriented design.
Both syntactically and logically everything in
Java happens inside a class.</p>

<p>Even basic data primitives like integers
often need to be incorporated into classes before you can do many useful things
with them.  The class is the fundamental unit of Java programs,
not source code files like in C.  For instance consider the 
following Java program:</p>

<pre><code>class HelloWorld {

  public static void main (String args[]) {

    System.out.println("Hello World");

  }

}

class GoodbyeWorld {

  public static void main (String args[]) {

    System.out.println("Goodbye Cruel World!");

  }

}</code></pre>

Save this code in a single file called hellogoodbye.java in your javahtml directory,
and compile it with the command <kbd>javac hellogoodbye.java</kbd>.  
Then list the contents of the
directory.  You will see that the compiler has produced two separate class
files, HelloWorld.class and GoodbyeWorld.class.
<p></p>

<p>The second class is a completely independent program.  Type <kbd>java GoodbyeWorld</kbd>
and then type <kbd>java HelloWorld</kbd>.
These programs run and execute independently of each other although
they exist in the same source code file.  Off the top of my head I
can't think of why you might want two separate programs in the same
file, but if you do the capability is there.</p>

<p>It's more likely that you'll want more than one class in the
same file. In fact you'll see source code files with many
classes and methods.</p>

<p>In fact there are a few statements that can, at least at first glance,
appear outside a class.  Import statements appear at the start of a file outside of any
classes.  However the compiler replaces them with the contents of
the imported file which consists of, you guessed it, more classes.</p>

<h4><a name="xtocid181416">Interfaces</a></h4>

<p>Like we said, Java source is really just classes.  Import
statements are shorthand for many different classes; and
comments aren't really there (as far as the compiler is
concerned) in the first place.  However there is one thing
in Java source code that is neither a class nor a member of
a class.  That's an <dfn>interface</dfn>.  We're not going
to say much about interfaces yet since that's a subject for
a more advanced chapter.  However we will note that an
interface defines methods that a class implements.  In other
words it declares what certain classes <em>do</em>.  However
an interface itself <em>does</em> nothing.  All the
<strong>action</strong> at least, happens inside classes.</p>

<p>

</p><h3><a name="xtocid190367">FahrToCelsius</a></h3>

Java is not just used for the World Wide Web.  The next
program demonstrates a classic use of computers that
goes back to the earliest punch card machines.  It's reminiscent
of some of the very first useful programs I ever wrote. These were
designed to quickly calculate several dozen numbers to keep
me from having to do them by hand in physics lab.  It's also
borrowed directly from Kernighan and Ritchie.<p> 

</p><pre><code>// Print a Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {
  
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;      // lower limit of temperature table
  upper = 300;  // upper limit of temperature table
  step  = 20;     // step size

  fahr = lower;
  while (fahr &lt;= upper) {  // while loop begins here
    celsius = 5 * (fahr-32) / 9;
    System.out.print(fahr);
    System.out.print(" ");
    System.out.println(celsius);
    fahr = fahr + step;
  } // while loop ends here
} // main ends here

} //FahrToCelsius ends here </code></pre>


This program calculates the Celsius equivalent of Fahrenheit
temperatures between zero and three hundred degrees.  The first two lines of
the main method <dfn>declare</dfn> the variables we'll use.  That is
they specify the names and the types.  For now we use only integers.
In Java an <code>int</code> can have a value between -2,147,483,648 to 2,147,483,647.
More types will be forthcoming.
<p></p>

<p>Then we initialize the variables using statements like 
"<code>lower = 0</code>".  This sets <code>lower</code>'s initial
value to 0.  When used this way the equals sign is
called the <dfn>assignment operator</dfn>.
</p>

<p>After establishing the initial values for all our variables we 
go into the loop which does the main work of our program.  At the
beginning of each iteration of the loop <code>(fahr &lt;= upper)</code> checks to see 
if the value of <code>fahr</code>
is in fact less than or equal to the current value of <code>upper</code>.  If it is
then the computer executes the statements in the loop block
(everything between "while loop begins here" and 
"while loop ends here".)  Loops in Java are 
marked off by matching pairs of braces and may be nested.
</p>

<p><code>celsius = 5 * (fahr-32) / 9;</code> actually calculates the Celsius
temperature given the fahrenheit temperature.  The arithmetic operators here
do exactly what you'd expect. * means multiplication. - is subtraction. /
is division; and +, though not used in here, is addition. Precedence follows
normal algebraic conventions, and can be rearranged through parentheses.</p>

<p>Java
contains an almost complete set of arithmetic operators. Like C it is missing
an exponentiation operator.  For exponentiation you need to use
the pow methods in the java.lang.Math package.</p>

<p>Printing output is very similar to what you've seen before.
We use <code>System.out.print(fahr)</code> to print the
fahrenheit value, then <code>System.out.print("
")</code> to print a one-character string containing a
space, and finally <code>System.out.println(celsius);</code>
the Celsius value.</p>

<p>Finally we increment the value of <code>fahr</code> by
<code>step</code> to move on to the next value in the table.
</p>

<h4><a name="xtocid45977">Floating Point Variables</a></h4>

<p>You may have noticed something a little funny about the
above output.  The numbers aren't exactly correct.  Zero
degrees Fahrenheit is actually -17.778 degrees Celsius, not
-18 degrees Celsius as this program reports.  The problem is
that we used only integers here, not decimal numbers.  In
computer-speak decimal numbers are called "floating
point numbers."</p>

<p>Floating point numbers can represent a broader range of
values than integers. For example you can write very large
numbers like the speed of light (2.998E8 meters per second)
and very small numbers like Plank's constant (6.63E-27  )
using the same number of digits. On the other hand you lose
some precision that you probably didn't need for such large
and small numbers anyway.  </p>

<p>Some languages have a third kind of number called a fixed
point number.  This number has a set precision, for instance
two decimal places, and is often useful in monetary
calculations.  Java has no fixed point data type.</p>

<p>Using floating point numbers is no harder than using
integers.  We can make our Fahrenheit to Celsius program
more accurate merely by changing all our <code>int</code>
variables into <code>double</code> variables.</p>

<pre><code>// Print a more accurate Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {

    double fahr, celsius;
    double lower, upper, step;

    lower = 0.0;      // lower limit of temperature table
    upper = 300.0;  // upper limit of temperature table
    step  = 20.0;     // step size
 
    fahr = lower;
    while (fahr &lt;= upper) {  // while loop begins here
      celsius = 5.0 * (fahr-32.0) / 9.0;
      System.out.print(fahr);
      System.out.print(" ");
      System.out.println(celsius);
      fahr = fahr + step;
    } // while loop ends here
  } // main ends here

} //FahrToCelsius ends here 
</code></pre>

I've made one further change to the Fahrenheit to Celsius program.  All the integer
constants in the program like <code>5</code> and <code>9</code> have become 
 <code>5.0</code> and <code>9.0</code> and so on.  If a constant number 
includes a decimal point, then the compiler assumes it's a double 
precision floating point number.  If it doesn't then the compiler 
assumes it's an integer.  However when two numbers of different types 
such as integer and floating
 point are involved in a calculation <em>on the right hand side of an equation</em>, 
 the compiler <dfn>promotes</dfn> the number of the
 weaker type to the stronger type before doing the calculation.  <p>
 
 What makes one type of number stronger than another?  It's the ability 
to represent a broader spectrum of numbers.  Since a byte can only 
represent 256 numbers it's weaker than a short which can stand for 
65,535 different numbers including all the numbers a byte can represent.
  Similarly an <code>int</code> is stronger than a <code>short</code>.
 Floating point numbers are stronger than any integer type and doubles are the strongest type
 of all.</p>

<p>Therefore we could have left all the small constants as integers and the program
output would have been unchanged.  However it is customary to put in decimal points to remind
yourself and anyone else who may be unlucky enough to have to read your code, exactly
what is going on.</p>

<p>This applies to calculations that take place on the right hand side of an equal sign.
The left hand side of the equals sign is a different story.  In fact it's so different that
programmers have given the different sides of the equals sign special names.  The left-hand side is called an <dfn>lvalue</dfn> while the right hand side is called an <dfn>rvalue</dfn>.  </p>

<p>An rvalue is a calculated result and as specified above it takes on the strongest type of any
number involved in the calculation.  On the other hand the lvalue has a type that must be defined
before it is used. 
That's what all those <code>float fahr, celsius;</code> statements are doing.  Once the type of an
lvalue is defined it never changes.  Thus if we declare <code>fahr</code> to be an <code>int</code>, then on the left
hand side of an equals sign <code>fahr</code> will always be an <code>int</code>, never
a <code>float</code> or a <code>double</code> or a <code>long</code>.</p>

<p>If you've been following along you may notice a problem here.  What if the
type on the left doesn't match the type on the right?  e.g. what happens with code 
like the following?</p>

<pre><code>class FloatToInt  {

  public static void main (String args[]) {

    int myInteger;

    myInteger = 9.7;

  } // main ends here

} //FloatToInt ends here </code></pre>

Two things can happen.  If, as above, we're trying to move a number into a weaker type
of variable, the compiler generates an error.  On the other hand if we're trying
to move a weaker type into a stronger type then the compiler converts it to the
stronger type.  For instance the following code is legal:<p></p>

<pre><code>class IntToFloat  {

  public static void main (String args[]) {

    float myFloat;
    int   myInteger;

    myInteger = 9;
    myFloat = myInteger;
    System.out.println(myFloat);

  } // main ends here

} //IntToFloat ends here </code></pre>


<h6>Exercises</h6>

<ol>
<li>Have the FahrToCelsius program print a heading above the table.
</li><li>Write a similar program to convert Celsius to Fahrenheit.
</li></ol>

<h3><a name="xtocid45978">The For Statement</a></h3>

Java isn't as redundant as perl, but there's still almost always more than one way
to write any given program.  The following program produces identical output to the 
Fahrenheit to Celsius program in the preceding section.  The main difference is the
<code>for</code> loop instead of a <code>while</code> loop.<p></p>

<pre><code>// Print a Fahrenheit to Celsius table

class FahrToCelsius  {

  public static void main (String args[]) {
  
    int fahr, celsius;
    int lower, upper, step;

    lower = 0;      // lower limit of temperature table
    upper = 300;  // upper limit of temperature table
    step  = 20;     // step size

    for (fahr=lower; fahr &lt;= upper; fahr = fahr + step) {  
      celsius = 5 * (fahr-32) / 9;
      System.out.println(fahr + " " + celsius);
    } // for loop ends here

  } // main ends here

}</code></pre>

<p>
The only difference between this program and the previous one is that here we've used
a <code>for</code> loop instead of a <code>while</code> loop.  The <code>for</code> loop has identical syntax to C's <code>for</code> loops.
i.e.
</p>

<code>  for (initialization; test; increment) </code>

The initialization, in this case setting the variable <code>fahr</code> 
equal to the lower limit, happens
the first time the loop is entered and only the first time.  Then the first time and every time
after that when control reaches the top of the loop a test is made.  In our example the
test is whether the variable <code>fahr</code> 
is less than or equal to the upper limit.  If it is we execute
the code in the loop one more time. If not we begin executing the code that follows the loop.
Finally at the end of each loop the increment step is made.  In this case we
increase <code>fahr</code> by <code>step</code>.<p></p>

<p>If that's unclear let's look at a simpler example:</p>

<pre><code>//Count to ten

class CountToTen  {

  public static void main (String args[]) {
  
    int i;
    for (i=1; i &lt;=10; i = i + 1) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}</code></pre>

This program prints out the numbers from one to ten.  It begins by setting the
variable <code>i</code> to 1.  Then it checks to see if one is in fact less than or equal to
ten.  Since one is less than ten, the program prints it.  Finally it adds one to <code>i</code> and starts 
over.  <code>i</code> is now 2. The program checks to see if 2 is less than 10.  It is!  so the program prints
"2" and adds one to <code>i</code> again.  <code>i</code> is now three. 
 Once again the code checks to
see that 3 is less than or equal to 10.  This is getting rather boring 
rather quickly.  Fortunately computers don't get bored, and very soon 
computer has counted to the point
where <code>i</code> is now ten.  The computer prints "10" and adds one to ten.  
Now <code>i</code> is eleven.
Eleven is not less than or equal to ten so the computer does not print it.  Rather it moves
to the next statement after the end of the for loop, <code>System.out.println("All done!);</code>.
The computer prints "All Done!" and the program ends.<p></p>

<p>For loops do not always work this smoothly.  For instance consider the following program:</p>

<pre><code>//Count to ten??

class BuggyCountToTen  {

  public static void main (String args[]) {
  
    int i;
    for (i=1; i &lt;=10; i = i - 1) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}</code></pre>

This program counts backwards.  There's nothing fundamentally wrong with a program counting backwards,
but we're testing for <code>i</code> being bigger than ten.  Since <code>i</code>
 is never going to be
bigger than ten in this program, the program never stops.  (That's not 
completely true.  If you have a very fast machine or you wait long 
enough somewhere below negative two billion <code>i</code> will 
suddenly become a very large positive number and the program will halt.  
This happens because of vagaries in computer arithmetic we'll discuss later.  
Nonetheless this is still almost certainly a bug.
If you don't
want to wait for that to happen just type <kbd>Control-C</kbd> to abort 
the program.  This sort of behavior is referred to as an infinite loop 
and is a more common programming error than you might think.<p></p>

<p></p><h3><a name="xtocid45979">Assignment, Increment and Decrement Operators</a></h3>

In reality almost nobody writes <code>for</code> loops like we did in the previous sections.
They would almost certainly use the increment or decrement operators instead.  There are two
of these, <code>++</code> and <code>--</code> and they work like this.<p></p>

<pre><code>//Count to ten

class CountToTen  {

  public static void main (String args[]) {
    int i;
    for (i=1; i &lt;=10; i++) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

}

}</code></pre>

<p>
</p><pre><code>//Count to ten??

class BuggyCountToTen  {

  public static void main (String args[]) {
    int i;
    for (i=1; i &lt;=10; i--) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

  }

}</code></pre>


When we write <code>i++</code> we're using shorthand for <code>i = i
+ 1</code>.  When we say <code>i--</code> we're using shorthand for
<code>i = i - 1</code>.  Adding and subtracting one from a number
are such common operations that these special <dfn>increment</dfn>
and <dfn>decrement</dfn> operators have been added to the language. 
They also allow the compiler to be smarter about certain
optimizations on some CPU architectures, but mainly they make code
easier to write and read.<p></p>

<p>However what do you do when you want to increment not by one but by
two? or three? or fifteen? We could of course write <code>i = i +
15</code> but this happens frequently enough that there's another
short hand for the general add and assign operation,
<code>+=</code>.  We would normally write this as <code>i +=
15</code>.  Thus if we wanted to count from 0 to 20 by two's we'd
write:</p>

<pre><code>class CountToTwentyByTwos  {

  public static void main (String args[]) {
    int i;
    for (i=0; i &lt;=20; i += 2) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

 } //main ends here

}</code></pre>

As you might guess there is a corresponding <code>-=</code> operator.  If we wanted to count down from
twenty to zero by twos we could write:<p></p>

<pre><code>class CountToZeroByTwos  {

  public static void main (String args[]) {
    int i;
    for (i=20; i &gt;= 0; i -= 2) {  
      System.out.println(i);
    } 
    System.out.println("All done!");

  }

}</code></pre>

You should note that we also had to change the initialization and test components of the
<code>for</code> loop to count down instead of up.<p></p>

<p>There are also <code>*=</code> and <code>/=</code> operators
that multiply and divide by their right hand sides before
assigning.  In practice you almost never see these because
of the speed at which variables making use of them go to
either zero or Inf. If you don't believe me consider the
following cautionary tale.</p>

<p>Many centuries ago in India a very smart man is said to have
invented the game of chess. This game greatly amused the
king, and he became so enthralled with it that he offered to
reward the inventor with anything he wished, up to half his
kingdom and his daughter's hand in marriage.</p>

<p>Now the inventor of the game of chess was quite intelligent
and not a little greedy. Not being satisfied with merely
half the kingdom, he asked the king for the following
gift:</p>

<p>"Mighty King," he said, "I am but a humble
man and would not know what to do with half of your kingdom.
 Let us merely calculate my prize as follows.  Put onto the
first square of the chessboard a single grain of wheat. 
Then onto the second square of the chessboard two grains,
and onto the third square of the chessboard twice two
grains, and so on until we have covered the board with
wheat."</p>

<p>Upon hearing this the king was greatly pleased for he felt
he had gotten off rather cheaply. He rapidly agreed to the
inventor's prize. He called for a bag of wheat to be brought
to him, and when it arrived he began counting out wheat. 
However he soon used up the first bag and was not yet
halfway across the board.  He called for a second, and a
third, and more and more, until finally he was forced to
admit defeat and hand over his entire kingdom for lack of
sufficient wheat with which to pay the inventor.</p>

<p>How much wheat did the king need? Let's try to calculate it.
 Although we won't use physical wheat, we will soon find
ourselves in the same dire straits as the king. Remember
that a chessboard has 64 squares.</p>

<pre><code>class CountWheat  {

  public static void main (String args[]) {
  
    int i, j, k;

    j = 1;
    k = 0;

    for (i=1; i &lt;= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
    } 
    System.out.println("All done!");

  }

}</code></pre>

We can improve our results slightly (but only slightly) by changing our ints to longs like so:<p></p>

<pre><code>class CountWheat {

  public static void main (String args[]) {
  
    long i, j, k;

    j = 1;
    k = 0;

    for (i=1; i &lt;= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
    } 
    System.out.println("All done!");

  }

}</code></pre>

A long is an integer type variable that can hold up to 
9,223,372,036,854,775,807.  However even that isn't enough to count how 
much wheat the king owed.  Let's try using a double instead, the largest
 type of all.  <p></p>

<pre><code>class CountWheat {

  public static void main (String args[]) {
  
  int i;
  double j, k;
  
  j = 1.0;
  k = 0.0;
  
  for (i=1; i &lt;= 64; i++) {
      k += j;
      System.out.println(k);
      j *= 2;
  } 
  System.out.println("All done!");

}

}</code></pre>

A double can hold a number as large as 1.79769313486231570e+308.  That 
turns out to be large enough to count the king's debt which comes to 
1.84467e+019 grains of wheat, give or take a few billion grains. That's a
 lot of wheat.<p></p>

<h6>Exercises</h6>
<ol>
<li>Would a float be big enough to count how many grains of wheat the king owes?<p>
</p></li><li>Why isn't there a ** or a // operator? <p>
</p></li></ol>

<h3><a name="xtocid459713">Methods</a></h3>

All the programs we've written to date have been quite simple, well under fifty lines of code
each.  As programs grow in size it begins to make sense to break them into parts.  Each part
can perform a particular calculation and possibly return a value.  This is especially useful when
the calculation needs to be repeated at several different places in the program.  
It also helps to define a clearer picture of the flow of the program, much like an outline shows the flow of a book. <p></p>

<p>Each <dfn>calculation part</dfn> of a program is called a method.  Methods are logically the
same as C's functions, Pascal's procedures and functions, and Fortran's functions and subroutines.</p>

<p>The above programs have already used a number of methods although these were all 
methods provided by
the system.  When we wrote <code>System.out.println("Hello World!");</code> in the 
first program we were using the <code>System.out.println()</code> 
method. (To be more precise we were using the 
<code>println()</code> method of the <code>out</code> member of the <code>System</code> class, but we'll talk more about that in Chapter 4.)  The <code>System.out.println()</code>
 method actually requires quite a lot of code, but it is all stored for 
us in the System libraries. Thus rather than including that code every 
time we need to print, we just call the <code>System.out.println()</code> method.</p>

<p>You can write and call your own methods too. 
Let's look at a simple example.  Java has no built-in factorial method so we'll write one.  
The following is a simple program that requests a number from the user and then calculates
the factorial of that number. </p>

<p>We'll use two methods in the program, one that checks
to see if the user has in fact entered a valid positive integer, and another that
calculates the factorial.  However we'll start by writing the main method of the program:</p>

<pre><code>class Factorial {

  public static void main(String args[]) {

    int n;

    while ((n = getNextInteger()) &gt;= 0)  {
      System.out.println(factorial(n));
    }

  } // main ends here

}</code></pre>

Among other things this code demonstrates that methods make it possible 
to design 
the flow of a program without getting bogged down in the details.  We've
 simply named
two methods, getNextInteger() and factorial() without worrying about 
their exact implementations.  We can add the rest of the code in 
smaller, easier-to-understand pieces.  Let's write
the factorial method first.<p></p>

<pre><code>long factorial (long n) {

  int i;
  long result=1;
  
  for (i=1; i &lt;= n; i++) {
   result *= i;
  }
  
  return result;

} // factorial ends here
</code></pre>

We could have included this code in our main method, but the algorithm 
is much easier to understand by breaking the code into smaller, more manageable pieces.
It's also easier to test and debug.  We can write a simple program that lets us test
the factorial method before we worry ourselves with the much harder problem of accepting 
and validating user input.  Here's the test program:<p></p>

<pre><code>class FactorialTest {

  public static void main(String args[]) {

    int n;
    int i;
    long result;

    for (i=1; i &lt;=10; i++)  {
      result = factorial(i);
      System.out.println(result);
    }

  } // main ends here
  
  
  static long factorial (int n) {

  int i;
  long result=1;
  
  for (i=1; i &lt;= n; i++) {
   result *= i;
  }
  
  return result;

} // factorial ends here


}</code></pre>


C++ programmers should take note that both methods are defined <em>inside</em> 
the class definition.  
Once again we see that in Java everything belongs to a class.<p></p>

<p>Let's take a closer look at the syntax of a method:

</p><pre><code> static long factorial (int n) {

  int i;
  long result=1;
  
  for (i=1; i &lt;= n; i++) {
   result *= i;
  }
  
  return result;

}</code></pre>

Methods begin with a declaration. This can include three to five
parts.  First is an optional <dfn>access specifier</dfn> which can
be public, private or protected. A public method can be called from
pretty much anywhere.  A private method can only be used within the
class where it is defined. A protected method can be used anywhere
within the package in which it is defined. Methods that aren't
specifically declared public or private are protected by default.<p></p>

<p>Next we decide whether the method is or is not static. Static
methods have only one instance per class rather than one instance
per object.  All objects of the same class share a single copy of a
static method.  By default methods are not static.</p>

<p>Next we specify the <dfn>return type</dfn>. This is the value that
will be sent back to the calling method when all calculations inside
the method are finished.  If the return type is int, for example, we
can use the method anywhere we use a constant integer. If the return
type is <dfn>void</dfn> then no value will be returned.</p>

<p>Next is the name of the method.</p>

<p>Then there are parentheses.  Inside the parentheses we give names
and types to the <dfn>arguments</dfn> of the method.  A method may
have no arguments or it may have one or several.  These arguments
can be used inside the method just like local variables.</p>

<p>Finally the rest of the method is enclosed in braces to make it a
single block. The part inside braces is just like the main methods
we've been exploring till now.  There are variable declarations,
some code, and finally something new, a return statement.  The
return statement sends a value back to the calling method.  The type
of this value must match the declared type of the method.</p>

<p>In general any line that looks like Text(arg1, arg2) or text(arg1)
or text() is a method call.  The compiler is responsible for
distinguishing between parentheses that mean method calls and
parentheses that serve as grouping operators in mathematical
expressions like (3 + 7) * 2. The compiler does a very good job of
this and you may safely assume that anything that isn't clearly an
arithmetical expression is a method call.</p>

<p>Methods break up a program into logically separate algorithms and
calculations.  In still larger programs it's necessary to break up
the data as well.  The data can be separated into different classes
and the methods attached to the classes they operate on.  This is
the heart of object oriented programming and the subject of Chapter
4 below.</p>

<h4><a name="xtocid1903615">Recursive Methods</a></h4>

<p>Java supports recursive methods, i.e. even if you're already inside methodA() you can call
methodA(). 
The easiest way I can think of to explain recursion is to look at a
simple acronym, GNU. The GNU project, among other things, is trying
to produce free versions of the Unix operating system and many Unix
tools, such as lex, yacc, and cc. One minor problem with this effort
is that the name Unix is trademarked so the GNU project can't use
it.  Hence, instead of Unix, we have GNU, where GNU stands for
"Gnu's Not Unix." The definition of GNU refers to itself; that is,
it's recursive.  So what is GNU? One level deeper it's "(Gnu's Not
Unix)'s Not Unix." One level deeper still, it becomes "((Gnu's Not
Unix)'s Not Unix)'s Not Unix." And so on, ad infinitum.  It's like
standing between a pair of mirrors. The images just fade off into
the distance with no clear end in sight. In computer programming
recursion is achieved by allowing  a method to call itself.</p>

<p>You probably already see one problem with recursion. Where does it
all end? In fact when you write recursive methods you have to be
careful to include stopping conditions. Although Java doesn't put
any particular limits on the depth to which you can expand a
recursion, it is very possible to have a run-away recursion eat up
all the memory in your computer. </p>

<p>Let's look at an example. n! (pronounced "En-factorial") is defined
as n times n-1 times n-2 times n-3 ... times 2 times 1 where n is a
positive integer. 0! is defined as 1. As you see n! = n time (n-1)!.
 This lends itself to recursive calculation, as in the following
method:</p>

<pre><code>public static long factorial (int n) {

  if (n == 0) {
    return 1;
  }
  else {
    return n*factorial(n-1);
  }

}</code></pre>


Something to think about: What happens if  a negative integer is
passed into the factorial method?  For example suppose you ask for
factorial(-1). Then you get the following chain of calls: -1 * -2 *
-3 * -4 * .... If you're lucky your program may unexpectedly pop
into the positive numbers and count down to zero. If you're not,
your program will crash with a StackOutOfMemoryError.  Stopping
conditions are very important.  In this case you should check to see
if you've been passed a negative integer; and, if you have been,
return infinity.  (<footnote>The factorial is a special case of the
gamma function for non-negative integers. Although the factorial
function is only defined for non-negative integers, the gamma
function is defined for all real numbers. It is possible to show
that the gamma function is infinite for negative
integers.</footnote>) Java doesn't support infinite values for
longs, though, so return the warning value -1 instead. (Java does
support infinite values for floats and doubles.) Here's a better
recursive factorial method:<p></p>

<pre><code>public static long factorial (int n) {

  if (n &lt; 0) {
    return -1;
  } 
  else if (n == 0) {
    return 1;
  }
  else {
    return n*factorial(n-1);
  }

}</code></pre>

It can be proven mathematically that all recursive algorithms have
non-recursive counterparts. For instance the factorial method could
have been written non-recursively like this:<p></p>

<pre><code>public static long factorial (int n) {

  long result = 1;
  
  for (int i = 1; i &lt;= n; i++) {
    result *= i;
  }
  
  return result;

}</code></pre>

The non-recursive equivalent in this problem is straight-forward,
but sometimes the non-recursive counterpart to a recursive algorithm
isn't at all obvious. To see that one always exists, note that at
the machine level of the computer, there's no such thing as
recursion and that everything consists of values on a stack.
Therefore even if you can't find a simpler way to rewrite the
algorithm without recursion, you can always use your own stack
instead of the Java stack. <p></p>

<p>Here's an example of a recursive program for which I have not
been able to find a simple, non-recursive equivalent method. The
goal is to find all possible RAM configurations for a PC,
given the size of the memory chips it will accept and the
number of slots it has available. We are not concerned with
how the RAM is arranged inside the PC, only with the total
quantity of installed RAM.  For some computers this can
easily be calculated by hand.  For instance Apple's
PowerBook 5300 series comes with 8 megabytes of RAM soldered
onto the logic board and one empty slot that can hold chips
of 8, 16, 32 or 56 MB capacity.  Therefore the possible Ram
configurations are 8, 16, 24, 40 and 64 MB.  However as the
number of available slots and the number of available chip
sizes increases this becomes a much more difficult problem. 
The following is a recursive program to calculate and print
all possible RAM configurations:</p><p>
</p><pre><code>
import java.util.Hashtable;
import java.util.Enumeration;

public class RamConfig {

   static int[] sizes = {0, 8, 16, 32, 64};
   static Hashtable configs = new Hashtable(64);
   static int slots[] = new int[4];

   public static void main (String args[]) {

     System.out.println("Available DIMM sizes are: ");
     for (int i=0; i &lt; sizes.length; i++) System.out.println(sizes[i]);

     fillSlots(slots.length - 1);
     System.out.println("Ram configs are: ");

     for (Enumeration e = configs.elements(); e.hasMoreElements(); ) {
       System.out.println(e.nextElement());    
     }
     
   }
   
  
  private static void fillSlots(int n) {
  
    int total;
     
    for (int i=0; i &lt; sizes.length; i++) {
       slots[n] = sizes[i];
       if (n == 0) {
          total = 0;
          for (int j = 0; j &lt; slots.length; j++) {
            total += slots[j];
          }
          configs.put(Integer.toString(total), new Integer(total));
       }
       else {
         fillSlots(n - 1);
       }
    }      
  
  }
  
}
</code></pre>

Recursive methods are also useful for benchmarking. In particular,
deep recursion tests the speed with which a language can make method
calls. This is important because modern applications have a tendency
to spend much of their time calling various API functions.  PCWeek
uses a benchmark they invented called Tak which performs 63,609
recursive method calls per pass. The algorithm is simple: If y is
greater than or equal to x, Tak(x, y, z) is z. This is the
nonrecursive stopping condition. Otherwise, if y is less than x,
Tak(x, y, z) is Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y)).
The Tak benchmark calculates Tak(18, 12, 6) between 100 and 10000
times and reports the number of passes per second. For more
information about the Tak benchmark see Peter Coffee's article, "Tak
test stands the test of time" on p. 91 of the 9-30-1996 PCWeek.
(<footnote>The article may be on <a href="http://www.pcweek.com/">PCWeek's web site</a> somewhere, but
regrettably that site, while it looks pretty, is lacking some basic
navigation aids. I was unable to locate the article, either directly
or through their search engine. If anyone finds the URL let me know.</footnote>)
<p></p>

<p>Below is my variation of this benchmark. There are overloaded
integer and floating point versions of the Tak method. Integer is
used by default. If the -f flag is given on the command line, the
floating point method is used. The number of passes to make may also
be entered from the command line. If it is not, 1000 passes are
made. The Java Date class is used to time that part of the test
where the benchmarking is done. </p>

<pre><code>import java.util.Date;


public class Tak {

  public static void main(String[] args) {
   
   boolean useFloat = false;
   int numpasses;
   
   for (int i = 0; i &lt; args.length; i++) {
     if (args[i].startsWith("-f")) useFloat = true;
   }
   try {
     numpasses = Integer.parseInt(args[args.length-1]);
   }
   catch (Exception e) {
     numpasses = 1000;
   }
   
   Date d1, d2;
   if (useFloat) {
     d1 = new Date();
     for (int i = 0; i &lt; numpasses; i++) {
        Tak(18.0f, 12.0f, 6.0f);
     }
     d2 = new Date();
   }
   else {
     d1 = new Date();
     for (int i = 0; i &lt; numpasses; i++) {
        Tak(18, 12, 6);
     }
     d2 = new Date();
   
   }
   long TimeRequired = d2.getTime() - d1.getTime();
   double numseconds = TimeRequired/1000.0;
   
   System.out.println("Completed " + numpasses + " passes in " 
    + numseconds + " seconds" );
   System.out.println(numpasses/numseconds + " calls per second");
  
  }

  public static int Tak(int x, int y, int z) {
    if (y &gt;= x) return z;
    else return Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y));   
  
  }

  public static float Tak(float x, float y, float z) {
    if (y &gt;= x) return z;
    else return Tak(Tak(x-1.0f, y, z), Tak(y-1.0f, z, x), Tak(z-1.0f, x, y));   
  
  }

}
</code></pre>

If you'd like to try this out right away, you can use the applet
interface to the Tak benchmark at <a href="http://metalab.unc.edu/javafaq/newsletter/TakApplet.html">http://metalab.unc.edu/javafaq/newsletter/TakApplet.html</a>.<p></p>

<p>My Powerbook 5300 achieved speeds between 3.5 and 5 passes per
second on this test.  Sun's Mac VM was about 10% faster on this test
than Natural Intelligence's. The heavily loaded Sparcstation at
metalab.unc.edu (load average 4+) achieved a little more than 3
passes per second.  Given the various external factors affecting
machine performance, these are hardly scientific measurements.  I'd
be curious to hear what your results are.</p>

<h6>Exercises</h6>
<ol>
<li>Find the non-recursive equivalent to the Ram Config algorithm.
</li></ol>

<h3><a name="xtocid459714">Arrays</a></h3>

In non-trivial computing problems you often need to store lists of
items.  Often these items can be specified sequentially and referred
to by their position in the list.  Sometimes this ordering is
natural as in a list of the first ten people to arrive at a sale. 
The first person would be item one in the list, the second person to
arrive would be item two, and so on. Other times the ordering
doesn't really mean anything such as in the ram configuration
problem of the previous chapter where having a 4 MB SIMM in slot A
and an 8 MB SIMM in slot B was effectively the same as an 8 MB SIMM
in slot A and a 4 MB SIMM in slot B.  However it's still convenient
to be able to assign each item a unique number and enumerate all the
items in a list by counting out the numbers.<p></p>

<p>There are many ways to store lists of items including linked lists,
sets, hashtables, binary trees and arrays. Which one you choose
depends on the requirements of your application and the nature of
your data. Java provides classes for many of these ways to store
data and we'll explore them in detail in the chapter on the Java
Class Library.</p>

<p>Arrays are probably the oldest and still the most generally
effective means of storing groups of variables.   An array is a
group of variables that share the same name and are ordered
sequentially from zero to one less than the number of variables in
the array. The number of variables that can be stored in an array is
called the array's <dfn>dimension</dfn>.  Each variable in the array
is called an <dfn>element</dfn> of the array. </p><p> An array can be
visualized as a column of data like so:</p>

<table>
<tbody><tr>
<td>
<table>
<tbody><tr align="left">
<td>
I[0]<br>
</td>
</tr>
<tr align="right">
<td>
I[1]<br>
</td>
</tr>
<tr align="right">
<td>
I[2]<br>
</td>
</tr>
<tr align="right">
<td>
I[3]<br>
</td>
</tr>
<tr align="right">
<td>
I[4]<br>
</td>
</tr>
</tbody></table>
<p>
</p></td>
<td>
<table border="1">
<tbody><tr align="right">
<td>
4<br>
</td>
</tr>
<tr align="right">
<td>
2<br>
</td>
</tr>
<tr align="right">
<td>
76<br>
</td>
</tr>
<tr align="right">
<td>
-90<br>
</td>
</tr>
<tr align="right">
<td>
6<br>
</td>
</tr>
</tbody></table>
<p>
</p></td>
</tr>
</tbody></table>

<p>In this case we're showing an integer array named <code>I</code>
with five elements; i.e. the type of the array is <code>int</code>
and the array has dimension 5. </p>

<h4><a name="xtocid499429">Creating Arrays</a></h4> 

<p>There are three steps to creating an array, declaring it, allocating
it and initializing it. </p><p> </p><h5>Declaring Arrays</h5> Like other
variables in Java, an array must have a specific type like byte,
int, String or double.  Only variables of the appropriate type can
be stored in an array.  You cannot have an array that will store
both ints and Strings, for instance.<p></p>

<p>Like all other variables in Java an array must be declared.  When
you declare an array variable you suffix the type with
<code>[]</code> to indicate that this variable is an array. Here are
some examples:</p>

<pre><code>int[] k;
float[] yt;
String[] names;
</code></pre>

In other words you declare an array like you'd declare any other
variable except you append brackets to the end of the variable
type.<p></p>

<p></p><h5>Allocating Arrays</h5>

 Declaring an array merely says what it is.  It
does not create the array.  
To actually create the array (or any other object)  use the
<code>new</code> operator.  When we create an array we 
need to tell the compiler how many elements will be stored in it.
Here's how we'd create the variables declared above:<p></p>

<pre><code>k = new int[3];
yt = new float[7];
names = new String[50];
</code></pre>

The numbers in the brackets specify the <dfn>dimension</dfn> of the
array; i.e. how many slots it has to hold values.  With the
dimensions above <code>k</code> can hold three ints, <code>yt</code> can hold seven floats and
names can hold fifty Strings.  Therefore this step is sometimes
called <dfn>dimensioning</dfn> the array.  More commonly this is
called <dfn>allocating</dfn> the array since this step actually sets
aside the memory in RAM that the array requires.<p></p>

<p>This is also our first look at the <dfn><code>new</code></dfn>
operator.  <code>new</code> is a reserved word in java that is used
to allocate not just an array, but also all kinds of objects.  Java
arrays are full-fledged objects with all that implies. For now the
main thing it implies is that we have to allocate them with
<code>new</code>.</p>

<p></p><h5>Initializing Arrays</h5>

Individual elements of the array are referenced by the array name
and by an integer which represents their position in the array.  The
numbers we use to identify them are called <dfn>subscripts</dfn> or
<dfn>indexes</dfn> into the array. Subscripts are consecutive
integers beginning with 0. Thus the array <code>k</code> above has elements <code>k[0]</code>,
<code>k[1]</code>, and <code>k[2]</code>.  
Since we started counting at zero there is no <code>k[3]</code>,
and trying to access it will generate an
<code>ArrayIndexOutOfBoundsException</code>. <p></p>

<p>You can use array elements wherever you'd use a similarly typed
variable that wasn't part of an array.</p>

<p>Here's how we'd store values in the arrays we've been working
with:</p>

<pre><code>k[0] = 2;
k[1] = 5;
k[2] = -2;
yt[6] = 7.5f;
names[4] = "Fred";
</code></pre>
This step is called initializing the array or, more precisely,
initializing the elements of the array.  Sometimes the phrase
"initializing the array" would be reserved for when we
initialize all the elements of the array.<p></p>

<p>For even medium sized arrays, it's unwieldy to specify each element
individually. It is often helpful to use <code>for</code> loops to
initialize the array.  For instance here is a loop that fills an
array with the squares of the numbers from 0 to 100.</p>

<pre><code>float[] squares = new float[101];

for (int i=0; i &lt;= 100; i++) {
  squares[i] = i*i;
}
</code></pre>

Two things you should note about this code fragment:<p>
</p><ul>
<li>Watch the fenceposts!  Since array subscripts begin at zero we need 101 elements if
we want to include the square of 100.</li>
<li>Although <code>i</code> is an int it becomes a float when it is stored in squares, 
since we've declared squares to be an array of floats.</li>
</ul>

<p>
 One way to avoid fencepost errors is to use the array's built-in length member. This
 tells you the  number of components in the array. In the example above, squares.length equals
  101. Thus the loop could have been written like this: </p>
  
<pre><code>float[] squares = new float[101];

for (int i=0, i &lt; squares.length; i++) {
  squares[i] = i*i;
}
</code></pre>
  
<p>
Note that the &lt;= changed to a &lt;  to make this work. </p>  

<h5>Shortcuts</h5>

<p>
It may seem to be a lot of work to set up arrays, particularly if
you're used to a more array friendly language like Fortran.
Fortunately Java has several shorthands for declaring, dimensioning
and strong values in arrays.</p>

<p>We can declare and allocate an array at the same time like this:</p>

<pre><code>int[] k = new int[3];
float[] yt = new float[7];
String[] names = new String[50];
</code></pre>

<p>
We can even declare, allocate, and initialize an array at the same time providing
a list of the initial values inside brackets like so:</p>

<pre><code>int[] k = {1, 2, 3};
float[] yt = {0.0f, 1.2f, 3.4f, -9.87f, 65.4f, 0.0f, 567.9f};
</code></pre>


<h4><a name="xtocid499430">Counting Digits</a></h4>

<p>
We've already seen one example of an array. Main methods in an
application store the command line arguments in an array of strings
called <code>args</code>.</p>

<p>As our second example let's consider a class that counts the
occurrences of the digits 0-9 in decimal expansion of the number pi,
for example.  This is an issue of some interest both to pure number
theorists and to theologians.  See, for example, <person>Carl
Sagan's</person> 
<cite><a href="http://www.amazon.com/exec/obidos/ISBN=0671004107/cafeaulaitA">Contact</a></cite> 
and <person>John
Updike's</person> <cite><a href="http://www.amazon.com/exec/obidos/ISBN=0449912183/cafeaulaitA">Roger's Version</a></cite>.  More realistically
we might wish to test the randomness of a random number generator.
If a random number generator is truly random, all digits should
occur with equal frequency over a sufficiently long period of time.
</p>

<p>We will do this by creating an array of ten longs called
<code>ndigit</code>.  The zeroth element of <code>ndigit</code> will
track the  number of zeroes in the input stream; the first element
of <code>ndigit</code> will track the numbers of 1's and so on. 
We'll test Java's random number generator and see if it produces
apparently random numbers.</p>

<pre><code>import java.util.*;

class RandomTest {

  public static void main (String args[]) {
  
    int[] ndigits = new int[10];
    double x;
    int n;
    
    Random myRandom = new Random();
  
    // Initialize the array 
    for (int i = 0; i &lt; 10; i++) {
      ndigits[i] = 0;
    }

    // Test the random number generator a whole lot
    for (long i=0; i &lt; 100000; i++) {
      // generate a new random number between 0 and 9
      x = myRandom.nextDouble() * 10.0;
      n = (int) x;
      //count the digits in the random number
      ndigits[n]++;
    }
    
    // Print the results
    for (int i = 0; i &lt;= 9; i++) {
      System.out.println(i+": " + ndigits[i]);
    }
  }
  
}

</code></pre>

<p>
We've got three <code>for</code> loops in this code, one to initialize the array, one to perform
the desired calculation, and a final one to print out the results. This is quite common
in code that uses arrays.</p>

<h4><a name="xtocid459715">Two Dimensional Arrays</a></h4>

<p> The most common kind of multidimensional array is a two-dimensional array.
If you think of a one-dimensional array as a column of values you can think
of a two-dimensional array as a table of values like so:</p>

<p><table border="1">
<tbody><tr>
<td>
</td>
<td>
c0<br>
</td>
<td>
c1<br>
</td>
<td>
c2<br>
</td>
<td>
c3<br>
</td>
</tr>
<tr>
<td>
r0<br>
</td>
<td>
0<br>
</td>
<td>
1<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
</tr>
<tr>
<td>
r1<br>
</td>
<td>
1<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
</tr>
<tr>
<td>
r2<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
</tr>
<tr>
<td>
r3<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
<td>
6<br>
</td>
</tr>
<tr>
<td>
r4<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
<td>
6<br>
</td>
<td>
7<br>
</td>
</tr>
</tbody></table>
</p><p>
Here we have an array with five rows and four columns.  It has twenty total elements.
However we say it has dimension five by four, not dimension twenty.  This array is not the 
same as a four by five array like this one:</p>

<p><table border="1">
<tbody><tr>
<td>
</td>
<td>
c0<br>
</td>
<td>
c1<br>
</td>
<td>
c2<br>
</td>
<td>
c3<br>
</td>
<td>
c4<br>
</td>
</tr>
<tr>
<td>
r0<br>
</td>
<td>
0<br>
</td>
<td>
1<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
</tr>
<tr>
<td>
r1<br>
</td>
<td>
1<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
</tr>
<tr>
<td>
r2<br>
</td>
<td>
2<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
<td>
6<br>
</td>
</tr>
<tr>
<td>
r3<br>
</td>
<td>
3<br>
</td>
<td>
4<br>
</td>
<td>
5<br>
</td>
<td>
6<br>
</td>
<td>
7<br>
</td>
</tr>
</tbody></table>
</p>

<p>We need to use two numbers to identify a position in a two-dimensional array.
These are the element's row and column positions.  For instance if the above array
is called J then J[0][0] is 0, J[0][1] is 1, J[0][2] is 2, J[0][3] is 3, J[1][0] is 1,
and so on.</p>

<p>Here's how the elements in a four by five array called M are referred to:</p>

<p><table border="1">
<tbody><tr>
<td>M[0][0]<br></td><td>M[0][1]<br></td><td>M[0][2]<br></td><td>M[0][3]<br></td><td>M[0][4]<br></td></tr>
<tr>
<td>M[1][0]<br></td><td>M[1][1]<br></td><td>M[1][2]<br></td><td>M[1][3]<br></td><td>M[1][4]<br></td></tr>
<tr>
<td>M[2][0]<br></td><td>M[2][1]<br></td><td>M[2][2]<br></td><td>M[2][3]<br></td><td>M[2][4]<br></td></tr>
<tr>
<td>M[3][0]<br></td><td>M[3][1]<br></td><td>M[3][2]<br></td><td>M[3][3]<br></td><td>M[3][4]<br></td></tr>
</tbody></table>
</p><p>
</p><h5>Declaring, Allocating and Initializing Two Dimensional Arrays</h5>

Two dimensional arrays are declared, allocated and initialized much like
one dimensional arrays.  However we have to specify two dimensions
rather than one, and we typically use two nested <code>for</code> loops to 
fill the array.<p></p>

<p>The array examples above are filled with the sum of their row and column
indices.  Here's some code that would create and fill such an array:</p>

<pre><code>class FillArray {

  public static void main (String args[]) {
  
    int[][] M;
    M = new int[4][5];
  
    for (int row=0; row &lt; 4; row++) {
      for (int col=0; col &lt; 5; col++) {
        M[row][col] = row+col;
      }
    }
    
  }
  
}</code></pre>

Of course the algorithm you would use to fill the array depends completely
on the use to which the array is to be put.  Here is a program which calculates
the identity matrix for a given dimension.  The identity matrix of dimension
N is a square matrix which contains ones along the diagonal and zeros in all
other positions.<p></p>

<pre><code>class IDMatrix {

  public static void main (String args[]) {
  
    double[][] ID;
    ID = new double[4][4];
  
    for (int row=0; row &lt; 4; row++) {
      for (int col=0; col &lt; 4; col++) {
        if (row != col) {
          ID[row][col]=0.0;
        }
        else {
          ID[row][col] = 1.0;
        }
      }
    }
    
  }
  
}</code></pre>

In two-dimensional arrays ArrayIndexOutOfBounds errors occur
whenever you exceed the maximum column index or row index.  Unlike
two-dimensional C arrays, two-dimensional Java arrays are not just
one-dimensional arrays indexed in a funny way.<p></p>

<h6>Exercises</h6>

<ol>
<li>Write a program to generate the HTML for the above tables.
</li></ol>

<h4><a name="xtocid2801933">Multidimensional Arrays</a></h4>

You don't have to stop with two dimensional arrays.  Java lets you
have arrays of three, four or more dimensions.  However chances are
pretty good that if you need more than three dimensions in an array,
you're probably using the wrong data structure.  Even three
dimensional arrays are exceptionally rare outside of scientific and
engineering applications.<p></p>

<p>The syntax for three dimensional arrays is a direct extension of
that for two-dimensional arrays.  Here's a program that declares,
allocates and initializes a three-dimensional array:</p>

<pre><code>class Fill3DArray {

  public static void main (String args[]) {
  
    int[][][] M;
    M = new int[4][5][3];
  
    for (int row=0; row &lt; 4; row++) {
      for (int col=0; col &lt; 5; col++) {
        for (int ver=0; ver &lt; 3; ver++) {
          M[row][col][ver] = row+col+ver;
        }
      }
    }
    
  }
  
}</code></pre>


We need three nested <code>for</code> loops here to handle the extra
dimension. <p></p>

<p>The syntax for still higher dimensions is similar.  Just add another
pair pf brackets and another dimension.</p>

<h4><a name="xtocid2801934">Unbalanced Arrays</a></h4>

<p>Like C Java does not have true multidimensional arrays.  Java fakes
multidimensional arrays using arrays of arrays.  This means that it
is possible to have <dfn>unbalanced arrays</dfn>. An unbalanced
array is a multidimensional array where the dimension isn't the same
for all rows.  IN most applications this is a horrible idea and
should be avoided.</p>

<h4><a name="xtocid2801935">Searching</a></h4>

<p>One common task is searching an array for a specified value. 
Sometimes the value may be known in advance.  Other times you may
want to know the largest or smallest element.</p>

<p>Unless you have some special knowledge of the contents of the array
(for instance, that it is sorted) the quickest algorithm for
searching an array is straight-forward linear search. Use a
<code>for</code> loop to look at every element of the array until
you find the element you want.  Here's a simple method that prints
the largest and smallest elements of an array:</p>

<pre><code>   static void printLargestAndSmallestElements (int[] n) {
  
    int max = n[0];
    int min = n[0];
    
    for (int i=1; i &lt; n.length; i++) {
      if (max &lt; n[i]) {
        max = n[i];
      }
      if (min &gt; n[i]) {
        min = n[i];
      }
    }
    
    System.out.println("Maximum: " + max);
    System.out.println("Minimum: " + min);
    
    return;
  
  }
  </code></pre>

<p>If you're going to search an array many times, you may want to sort the array, 
before searching it.  We'll discuss sorting algorithms in the next section.</p>

<h4><a name="xtocid2801936">Sorting</a></h4>

<p>All sorting algorithms rely on two fundamental operations, comparison and swapping.
Comparison is straight-forward. Swapping is a little more complex.  Consider
the following problem.  We want to swap the value of <code>a</code> and <code>b</code>.  
Most people propose something like this as the solution:</p><p>
</p><pre><code>class Swap1 {

  public static void main(String args[]) {
  
   int a = 1;
   int b = 2;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);
   
   // swap a and b
   
   a = b;
   b = a;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);   
  
  }

}</code></pre>

This produces the following output:<p></p>

<pre><samp>
a = 1
b = 2
a = 2
b = 2
</samp></pre>

That isn't what you expected!  The problem is that we lost track
of the value 1 when we put the value of <code>b</code> into <code>a</code>.  To correct
this we need to introduce a third variable, <code>temp</code>, to hold the
original value of <code>a</code>.<p></p>

<pre><code>class Swap2 {

  public static void main(String args[]) {
  
   int a = 1;
   int b = 2;
   int temp;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);
   
   // swap a and b
   
   temp = a;
   a = b;
   b = temp;
   
   System.out.println("a = "+a);
   System.out.println("b = "+b);   
  
  }

}</code></pre>


This code produces the output we expect:<p>
</p><pre><samp>
a = 1
b = 2
a = 2
b = 1
</samp></pre>


<h5>Bubble Sort</h5>

Now that we've learned how to properly swap the values of two
variables, let's proceed to sorting.  There are
<strong>many</strong> different sorting algorithms.  One of the
simplest and the most popular algorithms is referred to as
<dfn>bubble sort</dfn>.  The idea of bubble sort is to start at
the top of the array.  We compare each element to the next
element.  If its greater than that element then we swap the two.
 We pass through the array as many times as necessary to sort
it.  The smallest value bubbles up to the top of the array while
the largest value sinks to the bottom. (You could equally well
call it a sink sort, but then nobody would know what you were
talking about.)  Here's the code:<p></p>

<pre><code>import java.util.*;

class BubbleSort {

  public static void main(String args[]) {
  
   int[] n;
   n = new int[10];
   Random myRand = new Random();
   
   // initialize the array
   for (int i = 0; i &lt; 10; i++) {
     n[i] = myRand.nextInt();
   }
   
   // print the array's initial order
   System.out.println("Before sorting:"); 
   for (int i = 0; i &lt; 10; i++) {
     System.out.println("n["+i+"] = " + n[i]);
   }
   
   boolean sorted = false;
   // sort the array
   while (!sorted) {
     sorted = true;
     for (int i=0; i &lt; 9; i++) {
       if (n[i] &gt; n[i+1]) {
         int temp = n[i];
         n[i] = n[i+1];
         n[i+1] = temp;
         sorted = false;
       }   
     }
   }

  // print the sorted array
  System.out.println();
  System.out.println("After sorting:");  
   for (int i = 0; i &lt; 10; i++) {
     System.out.println("n["+i+"] = " + n[i]);
   }

  
  }

}</code></pre>

In this case we have sorted the array in ascending order,
smallest element first.  It would be easy to change this to
sort in descending order.<p></p>

<p>
</p><h3><a name="xtocid181428">Catching Exceptions</a></h3>

Do you remember this code?

<pre><code>// This is the Hello program in Java
class Hello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      System.out.print("Hello ");
      System.out.println(args[0]);
  }

}</code></pre>

Do you remember what happened when you ran the program
without giving it any command line arguments?  The runtime
system generated an exception<p></p>

<p><samp>Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
  at Hello.main(C:\javahtml\Hello.java:7)</samp></p>

<p>What happened was that since we didn't give Hello any command
line arguments there wasn't anything in <code>args[0]</code>. 
Therefore Java kicked back this not too friendly error message
about an "ArrayIndexOutOfBoundsException."</p>

<p>Previously we fixed
this problem by testing the length of the array before we tried to access its first element.
This worked well in this simple case, but this is far from the only such potential problem.  
If you were to check for every possible error condition in each line of code, you would 
find your code becoming bloated with more error checking than actual code.  
Moreover you then have to start checking for errors in the error conditions.
In older languages like C, Basic and Fortran you sooner or later you find yourself 
resorting to goto or longjmp or other such ingredients in the recipe for illegible 
Spaghetti Code</p>

<p>The goal of exception handling is to be able to define the regular flow of the program in 
part of the code without worrying about all the special cases.  Then, 
in a separate block of code, you cover the exceptional cases.  This 
produces more legible code since you don't need to interrupt the flow of the algorithm to
check and respond to every possible strange condition.  The runtime environment is
responsible for moving from the regular program flow to the exception handlers
when an exceptional condition arises.</p>

<p>In practice what you do is write blocks of code that may generate exceptions inside 
try-catch blocks.  You try the statements that generate the exceptions.  Within your try
block you are free to act as if nothing has or can go wrong.  Then, within one or more
catch blocks, you write the program logic that deals with all the special cases.</p>

<p>Here's an example of exception handling in Java using the Hello World program above:</p>

<pre><code>// This is the Hello program in Java
class ExceptionalHello {

    public static void main (String args[]) {
    
      /* Now let's say hello */
      try {
        System.out.println("Hello " + args[0]);
      }
      catch (Exception e) {
        System.out.println("Hello whoever you are");      
      }
  }

}</code></pre>


Some exceptions need to be caught and dealt with while others
are generally considered to be so horrific that the runtime
system, just gives up.  The compiler will complain if you write
code that doesn't watch out for the not-too-dangerous
exceptions, but you'll need to watch out for the really
dangerous ones (like ArrayIndexOutOfBoundsExceptions)
yourself.<p></p>

<p>Sometimes catching an exception can feel like a little yippy dog
that finally catches a car.  Now that it's got hold of the
bumper between its teeth, what is it going to do with it?  Many
times there may not be much you can do.  Bad exceptions stop the
program by default.  This is at least preferable to unhandled
exceptions in most programming languages where the entire system
can come crashing down around your feet with a core dump or
worse.  Sometimes you may want to this too.  In that case you
can call the <code>System.exit(int)</code> method to halt your
running program. </p>

<p>Other times you may just break out of a loop you were in and
continue with the rest of your code. This is most common when an
exception isn't really unexpected or when it doesn't badly
affect your program logic.  </p>

<p>You may or may not print an error message.  If you write an
exception handler and you don't expect it to be called, then by
all means put a </p>

<p><code>System.out.println("Error: " + e);</code></p>

<p>in your exception handler.  That way if something does go wrong
(and something always does) you'll at least know where it went
wrong. However don't put an error message in exception handlers
you expect to be exercised in the course of normal program flow.
 Remember, they're exceptions, not errors.</p>

<p>In the next section we'll see lots of examples of code that can
possibly generate exceptions which must be caught.  We'll talk
more about exceptions in a later chapter, but this is the bare
bones you need to know to respond to the exceptions generated by
the java.io classes we'll be discussing in the next section.</p>

<p></p><h3><a name="xtocid459717">File I/O and Streams</a></h3>

Sometimes you write data to a file instead of the computer
screen. Under Unix and DOS you can sometimes do this using the
redirection operators <kbd>&lt;</kbd> and <kbd>&gt;</kbd>. 
However sometimes you need a more fine-grained approach that
writes only certain data to a file while still putting other
data on the screen. Or you may need access to multiple files
simultaneously. Or maybe you want to query the user for input
rather than accepting it all on the command line. Or maybe you
want to read data out of a file that's in a particular format. 
In Java  all these methods take place as <dfn>streams</dfn>.<p></p>

<p>Streams are a big topic in Java and later we'll devote an entire
chapter to them. For now we want to cover just the very basics
that let you write files, read files and communicate with the
user.   In fact the <code>System.out.println()</code> statement
we've been using all along is an implementation of Streams.</p>

<h4><a name="xtocid69323">Interactively communicating with the
user</a></h4>

<p>We'll begin by writing a very simple program that asks the user
for their name and then prints a personalized greeting.</p>

<pre><code>import java.io.*;

class PersonalHello {

  public static void main (String args[])
    {
    
      byte name[] = new byte[100];
      int bytesRead = 0;

      System.out.println("What is your name?");
      try {
        bytesRead = System.in.read(name);
        System.out.print("Hello ");
        System.out.write(name, 0, bytesRead);
      }
      catch (IOException ex) {
        System.out.print("I'm Sorry.  I didn't catch your name.");
      }
      
    }
    
}</code></pre>

<p>
In code that does any significant input or output you'll want to
begin by importing all the various java.io classes. 
<code>import.java.io.*;</code> does this and is as ubiquitous in
Java applications as <code>#include &lt;stdio.h&gt;</code> is in C
programs.</p>

<p>Most of the reading and writing you do in Java will be done with
bytes. (As you'll see later there are also ways to read text files
directly into Strings.) Here we've started with an array of bytes
that will hold the user's name.</p>

<p>First we print a query requesting the user's name.  Then we read the
user's name using the  <code>System.in.read()</code> method.  This
method takes a byte array as an argument, and places whatever the
user types in that byte array.  Then, like before, we print
"Hello." Finally we print the user's name.</p>

<p>The program doesn't actually see what the user types until he or she
types a carriage return. This gives the user the chance to backspace
over and delete any mistakes.  Once the return key is pressed,
everything in the line is placed in the array.</p>

<p>What happens if the user types more than 100 characters of text
before hitting a carriage return?  In many programming languages
this would lead to a rather nasty program crash.  It's also the sort
of bug that often gets out the door in a shipping product since
programmers often fail to test their programs against extreme
inputs.  However Java has been programmed a little more safely. 
<code>System.in.read()</code> won't read past the end of the array
even though we didn't explicitly check to make sure the input was
sufficiently small. My guess is that the
<code>System.in.read()</code> method internally checks the length of
the array it's been passed using the name.length property. </p>

<h4><a name="xtocid181431">Reading Numbers</a></h4>

<p>Often strings aren't enough.  A lot of times you'll want to ask the 
user for a number as input.  All user input comes in as strings so we 
need to convert the string into a number.  </p><p> 

Next we promised to write a <code>getNextInteger()</code> method that will accept an integer from
the user.  Here it is:</p>

<pre><code>  static int getNextInteger() {
  
    String line;
  
    DataInputStream in = new DataInputStream(System.in);
    try {
      line = in.readLine();
      int i = Integer.valueOf(line).intValue();
      return i;
    }
    catch (Exception e) {
      return -1;
    }
       
  } // getNextInteger ends here</code></pre>

<h4><a name="xtocid181432">Reading Formatted Data</a></h4>

<p>It's often the case that you want to read not just one
number but multiple numbers.  Sometimes you may need to read
text and numbers on the same line. For this purpose Java
provides the StreamTokenizer class.</p>

<h4><a name="xtocid69324">Writing a text file</a></h4>

<p>Sometimes you want to save your output for posterity rather
merely scrolling it across a screen. To do this we'll need
to learn how to write data to a file.  rather than create a
completely new program we'll modify the Fahrenheit to
Celsius conversion program to output to a file:</p>

<pre><code>// Write the Fahrenheit to Celsius table in a file

import java.io.*;

class FahrToCelsius  {

  public static void main (String args[]) {

    double fahr, celsius;
    double lower, upper, step;

    lower = 0.0;    // lower limit of temperature table
    upper = 300.0;  // upper limit of temperature table
    step  = 20.0;   // step size

    fahr = lower;
  
    try {

      FileOutputStream fout =  new FileOutputStream("test.out");

      // now to the FileOutputStream into a PrintStream
      PrintStream myOutput = new PrintStream(fout);
  
      while (fahr &lt;= upper) {  // while loop begins here
        celsius = 5.0 * (fahr-32.0) / 9.0;
        myOutput.println(fahr + " " + celsius);
        fahr = fahr + step;
      } // while loop ends here
  
    }  // try ends here
    catch (IOException e) {
      System.out.println("Error: " + e);
      System.exit(1);
    }
  
  } // main ends here

}</code></pre>


There are only three things necessary to write formatted output to a file rather than to the 
standard output:<p></p>

<p>
</p></li><li> Open a <dfn>FileOutputStream</dfn> using a line like<p> 

</p><pre><code>FileOutputStream fout =  new FileOutputStream("test.out");
</code></pre>  

This line initializes the FileOutputStream with the name of the file you want to write into.<p></p>

<p></p></li><li>Convert the FileOutputStream into a <dfn>PrintStream</dfn> using a statement like<p>
</p><pre><code>PrintStream myOutput = new PrintStream(fout);
</code></pre> 

The PrintStream is passed the FileOutputStream from step 1. <p>
</p></li><li> Instead of using <code>System.out.println()</code> use <code>myOutput.println()</code>. 
 <code>System.out</code> and <code>myOutput</code> are just different instances of the 
 <code>PrintStream</code> class.  To print to a different <code>PrintStream</code> we keep 
 the syntax the same but change the name of the <code>PrintStream</code>.  <p>


</p><h4><a name="xtocid69325">Reading a text file</a></h4>

Now that we know how to write a text file, let's try reading one. 
The following code implements the Unix cat utility in Java.  That is
it accepts a series of file names on the command line and then
prints those filenames to the standard output in the order they were
listed.<p></p>

<pre><code>// Imitate the Unix cat utility

import java.io.*;

class cat  {

  public static void main (String args[]) {
  
  String thisLine;

  //Loop across the arguments
  for (int i=0; i &lt; args.length; i++) {
 
  //Open the file for reading
  try {
    FileInputStream fin =  new FileInputStream(args[i]);

    // now turn the FileInputStream into a DataInputStream
    try {
      DataInputStream myInput = new DataInputStream(fin);
  
      try {
        while ((thisLine = myInput.readLine()) != null) {  // while loop begins here
          System.out.println(thisLine);
        } // while loop ends here
      }
      catch (Exception e) {
       System.out.println("Error: " + e);
      }
    } // end try
    catch (Exception e) {
      System.out.println("Error: " + e);
    }
  
   } // end try
   catch (Exception e) {
    System.out.println("failed to open file " + args[i]);
    System.out.println("Error: " + e);
  }
  } // for end here
  
  } // main ends here

}</code></pre>

<h3><a name="xtocid459718">Summing Up</a></h3>

If you've gotten this far, you're capable of doing a surprising amount
of real work in Java.  You may not think so since we haven't yet talked about
a lot of the modern features of Java like most of its object orientation, many
of the details of working with applets, or threads.  However it's important to realize 
what you do have.  Right now the Java you know is able to handle any problem
that past generations have handled with Basic and Fortran 77.<p></p>

<p>FahrToCelsius is a very basic application that could be written in almost any
programming language from the most ancient machine code to the most advanced
LISP machine.  Nonetheless it is important to notice that Java solves
this problem just as easily as would a language more commonly
associated with numeric and scientific programming such as
Fortran or C.  In fact this code was translated almost verbatim
from Kernighan and Ritchie.  Only a few minor semantic
changes were required to produce a valid, efficient Java program.
Although Java has many, many features that make it suitable for 
complex object-oriented applications, it is also fully suitable for
classic numerical programs, something that is not true of
competitors like SmallTalk or LISP.
</p>

<p>In fact Java can outperform even Fortran and C in 
numerical applications
when precision, reliability and portability are more
important than speed.  Java's true arrays with bounds checking
and its well-defined IEEE 754 floating point data types are
especially useful in this regard.</p>

<p>Since there is as of yet no native architecture compiler for
Java, it's too early to throw away your Fortran manuals. CPU
intensive applications will still be coded in Fortran. The
Java language itself (as opposed to its implementation) is
also lacking in a couple of important respects for numeric
computation. The lack of an exponentiation operator like
Fortran's <code>**</code> and the lack of a complex data
type are both troublesome to longtime Fortran programmers.
However neither is insurmountable.</p><p> Would anyone care to
write a Fortran to Java translator?
</p>

<p>In the next chapter we'll move beyond the 1970's to discuss
more modern features of Java including Objects, Applets,
Event Driven Programming and threads.</p>

<p></p><h2><a name="xtocid459719">Part 3: Applets</a></h2>

The last chapter was rooted solidly in the 1970's.  It used
techniques often referred to as "structured" or
"procedural programming" which were popular then.
(We skipped right over the most popular innovation of the
60's and the Basic programmer, spaghetti code). Certain
programmers are sometimes said to "Write Fortran in any
language," and that's more or less what we did.  You
now have the knowledge to accomplish with Java anything that
can be done within the bounds of ANSI-standard Fortran
77.<p></p>

<p>In this chapter we're going to move into the 1980's.  In
particular we're going to work with <dfn>event driven
programming</dfn>.  This style of programming should be very
familiar to Macintosh and Windows programmers.  In those
environments program logic doesn't flow from the top to the
bottom of the program as it does in most procedural code. 
Rather the operating system collects <dfn>events</dfn> and
the program responds to them.  These events may be mouse
clicks, keypresses, network data arriving on the Ethernet
port, or any of about two dozen other possibilities.  The
operating system looks at each event, determines what
program it was intended for, and places the event in the
appropriate program's <dfn>event queue</dfn>.</p>

<p>Every application program has an <dfn>event loop</dfn>.  
This is just a <code>while</code> loop which loops
continuously.  On every pass through the loop the
application retrieves the next event from its event queue
and responds accordingly.</p>

<p>Java applets behave similarly.  However the runtime
environment (i.e. the browser) takes care of the event loop
for the applet so there's no need to write one explicitly. 
Rather you need to have methods in your applet subclass that
respond to each kind of event you want to process.</p>

<p>This is all fairly abstract until you see some concrete
examples. Let's begin with a simple one.</p>

<p></p><h3><a name="xtocid459720">Hello World: The Applet</a></h3>

The reason people
are excited about Java as more than just another OOP language is because
it allows them to write interactive applets on the web.
<i>Hello World</i> isn't a very interactive program, but let's look
at a webbed version.<p></p>

<pre><code>import java.applet.Applet;    
import java.awt.Graphics; 
              
public class HelloWorldApplet extends Applet {

  public void paint(Graphics g) {
    g.drawString("Hello world!", 50, 25);
  }
  
}</code></pre>

This applet version of HelloWorld is a little more complicated than the 
HelloWorld application of the previous chapter, and it will take a little
more effort to run it as well.<p></p>

<p>First type in the source code and save it into  file called
 HelloWorldApplet.java in the javahtml/classes directory. Compile this file
 by typing
<kbd>javac HelloWorldApplet.java</kbd> at the command line prompt.</p>

<p>If all is well a file called HelloWorldApplet.class will be created. 
This file must be in your classes directory.</p>

<p>Now you need to create an HTML file that will include your applet. 
The following simple HTML file will do.  </p>

<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Hello World &lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;BODY&gt;
This is the applet:&lt;P&gt;
&lt;APPLET codebase="classes" code="HelloWorldApplet.class" width=200 height=200 &gt;&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

<p>Save this file as "HelloWorldApplet.html" in the javahtml directory.  
When you've done that load the HTML file
into a Java enabled browser such as HotJava or Netscape 2.0.  You should see the following:</p>

<pre><samp>This is the applet:
Hello World!
</samp></pre>

<p>If the applet compiled without error and produced a 
HelloWorldApplet.class file, and yet
you don't see the string "Hello World" in your browser chances are that 
the class file
is in the wrong place.  Make sure the .html file is in the javahtml 
directory and the compiled .class file is in the javahtml/classes 
directory.</p>

<h4><a name="xtocid459721">Examining the Hello World Applet</a></h4>

<p>The Hello World Applet adds several constructs to what we saw in the
Hello World Application.  Moving from top to bottom the first thing you notice is
the two lines:

</p><pre><code>import java.applet.Applet;    
import java.awt.Graphics;</code></pre>

<p>The <code>import</code> statement in Java is similar to the #include statement in C
or C++. It pulls in the classes that are contained in a package
elsewhere.  A package is merely a collection of related classes.  In
this case we're requesting access to the public classes contained in the
basic release, java.applet.Applet and java.awt.Graphics.  
Depending on the phase of the moon,
awt stands for
"advanced window toolkit" or "applet window toolkit".  You'll see a lot more of it.</p>

<p>The next change from the application is the Class definition:</p>

<p><code>public class HelloWorldApplet extends Applet</code> </p>

<p>The <i>extends</i> keyword indicates that this class is a <dfn>subclass</dfn> of the Applet class; or, to put it another way, Applet is a <dfn>superclass</dfn>
 of HelloWorldApplet.
The Applet class is defined in the java.applet.Applet 
package which we just imported. Since HelloWorldApplet is a subclass of 
the Applet class, 
our HelloWorldApplet automatically inherits all the functionality of the
 generic Applet class. Anything an Applet can do, the HelloWorldApplet 
can do too.</p>

<p>The next difference between the applet and the application is far less
obvious (except maybe to a longtime C programmer).  <em>There's no
main method!</em>  Applets don't need them. The main method is actually 
in the browser or the 
AppletViewer, not in the Applet itself.  Applets are like plugin code 
modules for Adobe Photoshop that provide extra functionality, but can't 
run without a main program to host them.</p>

<p>Rather than starting at a specific place in the code applets are
<em>event driven</em>.  An applet waits for one of a series of
events such as a key press, the mouse pointer being moved over the
applets visible area, or a mouse click and then executes the
appropriate event handler. Since this is our first program we only
have one event handler, <code>paint</code>. </p>

<p>Most applets need to handle the <code>paint</code> event. This event
occurs whenever a part of the applet's visible area is uncovered and
needs to be drawn again.</p>

<p>The paint method is passed a <code>Graphics</code> object which
we've chosen to call g. The Graphics class is defined in the
java.awt.Graphics package which we've imported. Within the paint
method we call g's  drawString method to draw the string "Hello
World!" at the coordinates (50,25). That's 50 pixels across and
twenty-five pixels down from the upper left hand corner of the
applet.  We'll talk more about coordinate systems later. This
drawing takes place whenever a portion of the screen containing our
applet is covered and then uncovered and needs to be refreshed.</p>

<p></p><h3><a name="xtocid459722">The APPLET HTML Tag</a></h3>

Applets are included on web pages using the &lt;APPLET&gt;
tag.  The  &lt;APPLET&gt; tag is perhaps most similar to the
&lt;IMG&gt; tag. Like &lt;IMG&gt; &lt;APPLET&gt; needs to
reference a source file that is not part of the HTML page on
which it is embedded.  IMG's do this with the SRC=
parameter. APPLET's do this with the CODE= parameter.  The
CODE parameter tells the browser where to look for the
compiled .class file.  It is relative to the location of the
source document.  Thus if you're browsing
http://metalab.unc.edu/javafaq/index.html and that page
references an applet with CODE=animation.class, then the
animation.class file needs to be at
http://metalab.unc.edu/javafaq/animation.class.<p></p>

<p>For reasons that remain a mystery to HTML authors
everywhere, but possibly having something to do with
packages and classpaths, if the applet resides somewhere
other than the same directory as the page it lives on, then
you don't just give a URL to its location. Rather you point
at the directory where the .class file is using the
CODEBASE parameter.  You still also have to use CODE to give
name of the .class file.</p>

<p>Also like IMG, APPLET has several parameters to define how
it is positioned on the page. HEIGHT and WIDTH parameters 
work exactly as they do with IMG, specifying how big a
rectangle the browser should leave for the applet.  These
numbers are specified in pixels. ALIGN also works exactly as
for images (in those browsers that support ALIGN) defining
how the applet's rectangle is placed on the page relative
to other elements.  Possible values include LEFT, RIGHT,
TOP, TEXTTOP, MIDDLE, ABSMIDDLE, BASELINE, BOTTOM and
ABSBOTTOM.  Finally as with IMG you can specify an HSPACE
and a VSPACE in pixels to set the amount of blank space
between an applet and the surrounding text.</p>

<p>Finally also like IMG, APPLET has an ALT tag.  As far as I
know ALT is not yet implemented in any browsers.  An ALT tag
is used by a browser that understands the APPLET tag but
for some reason cannot play the applet.  For instance if an
applet needs to write a file on your hard drive, but your
preferences are set not to allow that, then the browser
should display the ALT text.</p>

<p>ALT is not used for browsers that do not understand APPLET
at all.  For that purpose APPLET has been defined to include
a closing tag as well, &lt;/APPLET&gt;. All raw text between
the opening and closing APPLET tags is ignored by a Java
capable browser. However a non-Java capable browser will
ignore the APPLET tags instead and read the text between
them.</p>

<h4><a name="xtocid1903625">Passing Parameters to Applets</a></h4>

<p>The area between the opening and closing APPLET tag is also
used to pass parameters to applets.  This is done through
the use of the PARAM HTML tag and the getParameter method of
the java.applet.Applet class.</p>

<p>To demonstrate this we'll convert HelloWorldApplet into a
generic string drawing applet. To do this we'll need to pass
the applet <dfn>parameters</dfn> that define the string to
be drawn.</p>

<pre><code>import java.applet.Applet;    
import java.awt.Graphics; 
             
public class DrawStringApplet extends Applet {

  String input_from_page;

  public void init() {
    input_from_page = getParameter("String");
  }
  
  public void paint(Graphics g) {
    g.drawString(input_from_page, 50, 25);
  }
  
}</code></pre>

Now you need to create an HTML file that will include your applet. 
The following simple HTML file will do:  <p></p>

<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Draw String &lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;BODY&gt;
This is the applet:&lt;P&gt;
&lt;APPLET codebase="classes" code="DrawStringApplet.class" width=200 height=200&gt;&lt;PARAM name="String" value="Howdy, there!"&gt;&lt;/APPLET&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
Of course you are free to change "Howdy, there!" to a string of your choice.
Note that this allows you to change the output of the applet without changing or recompiling the code.<p></p>

<p>You're not limited to one parameter either.  You can pass as
many named parameters to an applet as you like.</p>

<p>The <code>getParameter</code> method is straightforward.  You give it a
string that's the name of the parameter you want.  You get
back a string that's the value of the parameter.  All
parameters are passed as Strings. If you want to get
something else like an integer then you'll need to pass it
as a String and convert it into the type you really want.</p>

<p>The <code>PARAM</code> HTML tag is also straightforward. It occurs
between <code>&lt;APPLET&gt;</code> and <code>&lt;/APPLET&gt;</code>.  It has two
parameters of its own, NAME and VALUE.  The NAME identifies
which parameter this is for the <code>getParameter</code> method.  VALUE
is the value of the parameter as a String.  Both must be
enclosed in double quote marks like all other HTML tag
parameters.</p>

<p></p><h3><a name="xtocid459723">Events and Applets</a></h3>

<h4><a name="xtocid459724">Event Tutor Applet</a></h4>

The following applet is designed to give you some feel for just what
event driven programming is like and what the various events you're likely to
encounter are. Whenever an event occurs, the applet
responds by printing the name of the event at the command line. <p></p>

<pre><code>import java.applet.Applet;
import java.awt.*;
              
public class EventTutor extends Applet {

  public void init() {
    System.out.println("init event");
  }
  
  public void paint(Graphics g) {
    System.out.println("paint event");
  }
    
  public void start() {
    System.out.println("start event");
  }
 
  public void destroy() {
    System.out.println("destroy event");
  }
 
  public void update(Graphics g) {
    System.out.println("update event");
  }
  
  public boolean mouseUp(Event e, int x, int y) {
    System.out.println("mouseUp event");
    return false;
  }
  
  public boolean mouseDown(Event e, int x, int y) {
   System.out.println("mouseDown event");
   return false;
  }
  
  public boolean mouseDrag(Event e, int x, int y) {
    System.out.println("mouseDrag event");
        return false;
  }
  
  public boolean mouseMove(Event e, int x, int y) {
    System.out.println("mouseMove event");
    return false;
  }
  
  public boolean mouseEnter(Event e, int x, int y) {
    System.out.println("mouseEnter event");
    return false;
  }
  
 public boolean mouseExit(Event e, int x, int y) {
    System.out.println("mouseExit event");
    return false;
  }
  
  public void getFocus() {
    System.out.println("getFocus event");
  }
  
  public void gotFocus() {
    System.out.println("gotFocus event");
  }
  
  public void lostFocus() {
    System.out.println("lostFocus event");
  }
  
  public boolean keyDown(Event e, int x) {
    System.out.println("keyDown event");
    return true;
  }
  
}
</code></pre>

Once you've compiled and loaded this applet play with it.  Click
the mouse in the applet window. Doubleclick the mouse.  Click
and drag.  Type some text.  Resize the browser window. Cover it
and then uncover it.  Keep your eye on the standard output (Java
console in Netscape) while doing this.<p></p>

<p>
Here are some questions to answer:</p>

<p>
</p></li><li>Can you have a mouseDown event that is not followed by a mouseUp event?
</li><li>Can you have a mouseDown event that is not followed by a mouseDrag event?
</li><li>Can you have a mouseUp Event that is not preceded by a mouseDown event?
</li><li>What has to happen for a paint event to occur?
</li><li>What's the most common event? Why?
</li><li>Are there any events you don't see?
</li><li>How many times can you make the start event get called? the stop event?
</li><li>Of those events you can make occur, exactly how do you do it? 
How many different ways can you do it?



There are a number of new things in this code but none of
them are particularly difficult.  The first one is the
second import statement, <code>import java.awt.*</code>. 
This time we need more than one class from the awt package
so rather than worrying about which one to import, we just
get them all with the <code>*</code>.  The compiler is smart enough to
only link in those that it actually uses.<p></p>

<p>Finally there are a whole lot of new event methods.  We'll
cover them in detail in the next section.  For now see under
what circumstances you can make each one happen.</p>

<h4><a name="xtocid558854">Making a List</a></h4>

<p>It is extremely bad form to use
<code>System.out.println()</code> in an applet.  On some
systems this may not work at all.  However it has the
advantage of being familiar and easy.  For more serious work
you should actually draw your text in the applet window. 
There are at least three different ways to do this.  For our
purposes the one that makes the most sense is to use a
<dfn>List</dfn>.</p>

<p>A List is a scrolling list of Strings defined in
<code>java.awt.List</code>.  We create a new List with new, just as we
create any other Object.  The specific constructor we use
asks for an int that's the number of visible lines and a
boolean that tells whether or not multiple selections are
allowed. We'll ask for 25 lines and no multiple
selections.</p>

<pre><code>
 List theList; 
 theList = new List(25, false);
</code></pre> 


<p>We add Strings to the list by using the addItem method of
the List we're adding to like so:</p>

<pre><code>
    theList.addItem("This is a list item");
</code></pre>

<p>Finally we need to actually add this List to our applet
(more precisely the applet's container). We do this with the
line</p>

<pre><code>
    add(theList);
</code></pre>
<p>
in the init method.
That's all. We can use the same applet we used before with these simple changes.</p>

<pre><code>import java.applet.Applet;
import java.awt.*;
              
public class EventList extends Applet {

  List theList; 

  public void init() {
    theList = new List(25, false);
    add(theList);
    theList.addItem("init event");
  }
  
  public void paint(Graphics g) {
    theList.addItem("paint event");
  }
    
  public void start() {
    theList.addItem("start event");
  }
 
  public void destroy() {
    theList.addItem("destroy event");
  }
 
  public void update(Graphics g) {
    theList.addItem("update event");
  }
  
  public boolean mouseUp(Event e, int x, int y) {
    theList.addItem("mouseUp event");
    return false;
  }
  
  public boolean mouseDown(Event e, int x, int y) {
   theList.addItem("mouseDown");
   return false;
  }
  
  public boolean mouseDrag(Event e, int x, int y) {
    theList.addItem("mouseDrag event");
        return false;
  }
  
  public boolean mouseMove(Event e, int x, int y) {
    theList.addItem("mouseMove event");
    return false;
  }
  
  public boolean mouseEnter(Event e, int x, int y) {
    theList.addItem("mouseEnter event");
    return false;
  }
  
 public boolean mouseExit(Event e, int x, int y) {
    theList.addItem("mouseExit event");
    return false;
  }
  
  public void getFocus() {
    theList.addItem("getFocus event");
  }
  
  public void gotFocus() {
    theList.addItem("gotFocus event");
  }
  
  public void lostFocus() {
    theList.addItem("lostFocus event");
  }
  
  public boolean keyDown(Event e, int x) {
    theList.addItem("keyDown event");
    return true;
  }
  
}
</code></pre>


<p>We'll talk more about containers, Lists, and applet components in a
later section.</p>

<h4><a name="xtocid2801953">The Events</a></h4>

<p>In this section we're going to categorize the events your applet
should respond to.  You may not always need to respond to each one. 
For some of the events we'll also include new methods for the
EventTutor applet that show a little more information.  When we do
you should replace the old method with the new one.</p>

<p></p><dl>
  <dt>init</dt><dd>
The <code>init()</code> method is called when your applet begins executing. 
Netscape is also known to call this method at other times such as
when an applet is reloaded or you return to a page containing an
applet.  Generally you use this method to set up any data structures
or perform any tasks you need to get ready to run the applet.  Since
it's only called once it's easy to miss the <code>init()</code> method in the
EventTutor applet. If necessary redirect the standard output to a
file and look at the first line of that file to see it.<p></p>

<pre><code>  public void init() {
    System.out.println("init event");
  }</code></pre>
  
  </dd><dt>paint</dt><dd>
  
We've already seen the <code>paint()</code> method. Almost any applet is going to
need to override this method.  This is the method in which you will
do all your drawing.  You can only write to the applet screen in the
paint method.  However there are times when you'll want to write to
an offscreen image in another method and then just quickly copy that
image to the screen in your <code>paint()</code> method.<p>
  
</p><pre><code>  public void paint(Graphics g) {
    theList.addItem("paint event");
  }</code></pre>
  
  
 </dd><dt>stop
  </dt><dd>
A <code>stop()</code> message says the user is no longer looking at the page that
contains the applet.  This is usually because the user left the page
or minimized the window. At this time you should stop any CPU eating
activities that don't matter when the user isn't looking at your
page.  For instance your Doom applet should stop tracking monster
movement if the user isn't actually playing. On the other hand a
spreadsheet applet  in the middle of a long calculation should
continue calculating because the user is likely to want the result
later.  Once the user returns to the page the <code>start()</code> method is
called. <p>
  
</p><pre><code>  public void stop() {
    theList.addItem("stop event");
  }</code></pre>
   
  </dd><dt>start
  </dt><dd>
  The start() method is called when a user brings their attention back 
to an applet,
  for instance after maximizing a window or returning to the applet's 
page.  It is called after the init() method. Initialization code that 
needs to be performed every time an applet is restarted should be put 
here.<p>
</p><pre><code>  public void start() {
    theList.addItem("start event");
  }</code></pre>
 

  </dd><dt>destroy</dt><dd>
  The destroy() method is called before the applet is unloaded 
completely. It is called after the stop() method.  Users may reload the 
applet later, but if they do it will be as if they've never seen it 
before.  All variables, static, member, local or otherwise will be 
initialized to their initial state. If you have any final cleanup to do 
(for instance 
  sending output back to the httpd server) do it here.<p> 

</p><pre><code>  public void destroy() {
    theList.addItem("destroy event");
  }</code></pre>
 
  </dd><dt>update
  </dt><dd>
  
  The <code>update()</code> method is called automatically by the system when ????. 
  It's often overridden when you want to use offscreen Images to avoid flicker.<p>
  
</p><pre><code>  public void update(Graphics g) {
    theList.addItem("update event");
  }</code></pre>
  
  </dd><dt>mouseUp</dt><dd>
The <code>mouseUp()</code> method is called whenever the mouse
button is <strong>released</strong> in your applet.  In most cases
this is the event you'll want to watchout for, not mouseDown. A
button is typically highlighted when the mouse button is pressed on
it, but it is not activated till the user releases the mouse button.
This gives the user a chance to change their mind by moving the
cursor off the object without releasing it.<p> 

The exception would
be when you want an action to continue as long as the mouse button
is held down, a fast forward button on a movie playing applet for
instance.</p><p> <code>mouseUp()</code> methods also receive the
coordinates of the point where the mouse was released.
</p><pre><code>  public boolean mouseUp(Event e, int x, int y) {
    theList.addItem("mouseUp event at (" + x + "," + y + ")");
    return false;
  }</code></pre>
  
  </dd><dt>mouseDown</dt><dd>
The <code>mouseDown()</code> method is called whenever the mouse
button is <strong>pressed</strong> in your applet.  In most cases 
you'll want to wait for a mouseUp before taking any action
though. <p> <code>mouseDown()</code> methods also receive the coordinates of the
point where the mouse was released. </p><p>
</p><pre><code>  public boolean mouseDown(Event e, int x, int y) {
    theList.addItem("mouseDown event at (" + x + "," + y + ")");
    return false;
  }</code></pre>
  
  </dd><dt>mouseDrag
  </dt><dd>
<code>mouseDrag()</code> methods occur when a user moves the mouse
while holding down the mouse button. <code>mouseDrag()</code>
methods receive the coordinates of the point where the mouse is when
the event occurs.<p>
  
</p><pre><code>  public boolean mouseDrag(Event e, int x, int y) {
    theList.addItem("mouseDrag event at (" + x + "," + y + ")");
        return false;
  }</code></pre>
  
  </dd><dt>mouseMove
  </dt><dd>
  mouseMove methods occur when a user moves the mouse without holding down the mouse button.
  mouseMove methods receive the coordinates of the point where the mouse is when the event occurs. <p></p>

<pre><code>  public boolean mouseMove(Event e, int x, int y) {
    theList.addItem("mouseMove event at (" + x + "," + y + ")");
    return false;
  }</code></pre>
  
  
  </dd><dt>mouseEnter</dt><dd>
  Your applet receives a mouseEnter event whenever the cursor enters 
your applet from 
  somewhere else.  You'll also receive the coordinates of the point at 
which the 
  cursor entered your applet. After this happens its typically followed 
by a Stream of mouseMoved events as the cursor continues through the 
applet so it can be hard to see.<p>
  
</p><pre><code>  public boolean mouseEnter(Event e, int x, int y) {
    theList.addItem("mouseEnter event at " + x + "," + y + ")");
    return false;
  }</code></pre>
  
 </dd><dt>mouseExit</dt><dd>
   Your applet receives a mouseExit event whenever the cursor leaves 
your applet.  You'll also receive the coordinates of the point at which 
the 
  cursor exited your applet.<p></p>

<pre><code> public boolean mouseExit(Event e, int x, int y) {
    theList.addItem("mouseExit event at (" + x + "," + y + ")");
    return false;
  }</code></pre>
  
  </dd><dt>getFocus</dt><dd>
<pre><code>  public void getFocus() {
    theList.addItem("getFocus event");
  }</code></pre>
  
  </dd><dt>gotFocus
  </dt><dd>public void gotFocus() {
    theList.addItem("gotFocus event");
  }
  
  </dd><dt>lostFocus</dt><dd>
<pre><code>  public void lostFocus() {
    theList.addItem("lostFocus event");
  }</code></pre>
  
  </dd><dt>keyDown
  </dt><dd>
  A keydown event is generated whenever the user presses a key while 
your applet is active.
  An integer keycode is returned indicating which key was pressed.  As a
 general rule you'll want to cast this to a char to get the actual 
letter.<p>
</p><pre><code>  public boolean keyDown(Event e, int x) {
    theList.addItem("The " + (char) x + " key was pressed.");
    return false;
  }</code></pre>

</dd></dl>
<p>
Here's the revised EventTutor Applet:</p>

<p></p><h3><a name="xtocid126135">Drawing Text</a></h3>


<h3><a name="xtocid459725">Drawing Graphics: Lines, Circles, Rectangles and Colors</a></h3>

<h4><a name="xtocid459726">Drawing Rectangles</a></h4>

Next we'll write an applet that fills the screen with lots of
randomly sized and positioned rectangles in the style of Piet
Mondrian.  In the process we'll learn the basics of applet graphics.
 We're going to take this one step at a time, adding a bit as we go.
<p></p>

<p>In the first applet we'll just draw a rectangle on the screen. 
We'll get the size of the applet as specified in the HTML file, and
then we'll draw a rectangle around the applet to frame it. Here's
the code:</p>

<pre><code>//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian1 extends Applet {

  int height, width;

  public void init() {
  
    Dimension d = size();
    height = d.height;
    width = d.width;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, width, height);
    
  }

}</code></pre>


Compile this applet; move the resulting class file to your
classes directory, and create an HTML file that points to
it.  Set the height of the applet to 300 pixels and the
width to 300 pixels as well. Load that file into your
browser and what do you see? Probably not what you expected.
 You should see half a rectangle.  What happened to the
other half?<p></p>

<p>This is called a <dfn>fencepost error.</dfn> The applet
lives in a square 300 pixels tall by 300 pixels wide.
However the upper left hand corner of the applet starts at
(0, 0), not at (1, 1). This means that the applet includes
the points with x and y coordinates between 0 and 299, not
between 0 and 300.  We drew a rectangle 301 pixels high and
301 pixels wide so the edges were chopped off.</p>

<p>This is fortuitous however.  Not only does it allow me the
opportunity to digress on fencepost errors (which, although
annoying, are far less dangerous in Java than in C since
Java does check array boundaries) but it also shows us
something else.  In Java the coordinate system for an applet
begins in the upper left hand corner and increases to the
right and down. This is common in computer graphics but is
different from the Cartesian coordinate system where the
direction of increasing y is generally assumed to be up.</p>

<p>Correcting the fence post error is easy.  We just change
<code>g.drawRect(0, 0, width, height);</code> to
<code>g.drawRect(0, 0, width-1, height-1);</code>

</p><pre><code>//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian2 extends Applet {

  int height, width;

  public void init() {
  
    Dimension d = size();
    height = d.height;
    width = d.width;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, width-1, height-1);
    
  }

}</code></pre>

As usual compile this and load it into your browser.  If the problem 
isn't fixed check to
make sure that you moved the new class file into the classes directory 
and that you modified the HTML file to point to Mondrian2.<p></p>

<p>We've introduced exactly one new statement in all this code, <code>drawRect</code> which is
a method in the Graphics class.  The line <code>g.drawRect(0, 0, height-1, width-1)</code>
instructs the Graphics class <code>g</code> to draw a rectangle beginning at the point
(0, 0) and ending at the point (299, 299). </p><p> 

This particular rectangles encompasses the entire
applet's visible space.  There is nothing to keep us from drawing outside the applet, in
fact we did exactly that in our first version where we actually extended the rectangle to
(300, 300); but anything we draw there won't be seen by the user.</p>

<p>The drawRect method draws an open rectangle.  If we want to draw a filled rectangle we use
the fillRect method.  Otherwise the syntax is identical.  In Mondrian3 we'll draw a filled
rectangle in the center of the applet.  
Here's the code:</p>

<pre><code>//Draw a rectangle

import java.applet.*;    
import java.awt.*; 

public class Mondrian3 extends Applet {

  int AppletHeight;
  int AppletWidth;
  int RectHeight;
  int RectWidth;
  int RectTop;
  int RectLeft;


  public void init() {
  
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectHeight = AppletHeight/3;
    RectWidth = AppletWidth/3;
    RectTop = (AppletHeight - RectHeight)/2;
    RectLeft= (AppletWidth - RectWidth)/2;
    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
    
  }

}
</code></pre>

This latest example also demonstrates one other thing.  Until now you 
may have thought
that we were passing two points to the drawRect and fillRect methods and
 drawing the rectangle
that joins them.  This is how rectangles are implemented in QuickDraw on
 the Mac for example.  However if that was the case the preceding 
rectangle would have been drawn between (100, 100)
and (100, 100), a fairly small rectangle.  Since that isn't the case our
 association of
the last two variables with width and height must be correct.<p></p>

<p>The extremely astute reader may object at this point.  Until now 
we've only drawn squares.
Although the last two variables passed to drawRect and fillRect must be 
the height and the width
how do we know which is which?  The simplest way to tell is to write a 
test program that draws a non-square rectangle. Let's try that now:</p>

<pre><code>//Draw a rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian4 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectHeight = AppletHeight/3;
    RectWidth = (AppletWidth*2)/3;
    RectTop = (AppletHeight - RectHeight)/2;
    RectLeft= (AppletWidth - RectWidth)/2;

    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }

}</code></pre>

So you see that the third argument is indeed the width and
the fourth is the height.<p></p>

<p>Now that we've learned how to draw rectangles, both filled
and unfilled, let's make life a little more exciting by
randomly selecting the position and size of the rectangle. 
To do this we'll need the Math.random() method from
java.lang.Math.  This method returns a double between 0.0
and 1.0 so we'll need to multiply the result by the applet's
height and width to get a reasonably sized rectangle that
fits into our applet space.  To do this we'll create the
following Randomize method:</p>

<pre><code>private int Randomize( int range )
{
  double  rawResult;
  
  rawResult = Math.random();
  return (int) (rawResult * range);

}</code></pre>

This method forces the result of Math.random into an <code>int</code> in the range we require.
Pay special attention to the last line.  When you see a raw type in parentheses like <code>(int)</code> or <code>(float)</code> it's a <dfn>cast</dfn>.  
Casts change one value type into another. 
Thus here we're changing a <code>double</code> into an <code>int</code>.  The cast rounds as necessary.<p></p>

<p>Casting in Java is safer than in C or other languages that
allow arbitrary casting.  Java only lets casts occur when
they make sense, such as a cast between a <code>float</code>
and an <code>int</code>. However you can't cast between an
<code>int</code> and a <code>String</code> for example.</p>

<pre><code>//Draw a rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian5 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);

    repaint();

  }

  public void paint(Graphics g) {

    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}</code></pre>

Occasionally this applet does randomly produce a rectangle that's two small to see
so if you don't see anything, reload it.  
Reload it a few times.  Each time you'll see a rectangle of
a different size appear in a different place. <p></p>

<p>Let's make our world a little more colorful.  To do this we'll change the 
rectangle color to red.  To do this we'll
use a new methods setColor(), part of the Graphics class.
</p>

<pre><code>//Draw a colored rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian6 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);

    repaint();

  }

  public void paint(Graphics g) {

   // g.setBackground(Color.white);
    g.setColor(Color.red);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
</code></pre>

The awt predefines a number of  colors including:<p></p>

<p></p><ul>
<li>black
</li><li>blue
</li><li>cyan
</li><li>darkGray
</li><li>gray
</li><li>green
</li><li>lightGray
</li><li>magenta
</li><li>orange
</li><li>pink
</li><li>red
</li><li>white
</li><li>yellow
</li></ul>

If these aren't sufficient for your needs, you can define
others using the same RGB triple that's used to set
background colors on many web pages.  You even get to use
decimal numbers instead of the hex values you have to use
for the bgcolor tag.  For example to select a medium gray
you'd use <code>Color(127, 127, 127)</code>.  Pure white
would be <code>Color(255, 255, 255)</code>.  Pure red is
<code>(255, 0, 0)</code> and so on. <p></p>

<p>By using the color constructor we can expand our program to
select not only a random rectangle but also a random color
for the rectangle. Here's the code:</p>

<pre><code>//Draw a randomly colored rectangle

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian7 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;

  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    RectTop = Randomize(AppletHeight);
    RectLeft= Randomize(AppletWidth);
    RectHeight = Randomize(AppletHeight - RectTop);
    RectWidth = Randomize(AppletWidth - RectLeft);
    RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));

    repaint();

  }

  public void paint(Graphics g) {

   // g.setBackground(Color.white);
    g.setColor(RectColor);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
    g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);

  }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}</code></pre>

In the next example we're going to draw multiple randomly sized, randomly colored
rectangles.  Since we want each rectangle to be different we're going to have to move the
calculation of the rectangle's shape, position and color into the paint() method. Here's the code:<p></p>

<pre><code>//Draw many randomly colored rectangles

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian8 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  int numberRectangles = 100;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;

    repaint();

  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i &lt; numberRectangles; i++)  {
      RectTop = Randomize(AppletHeight);
      RectLeft= Randomize(AppletWidth);
      RectHeight = Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
  }
  
 }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
</code></pre>

Finally let's let the HTML specify the number of rectangles to be drawn 
in one pass.  We'll keep the default value as is and only replace it if 
the HTML includes a Number PARAM.<p></p>

<pre><code>//Draw many random rectangles

import java.applet.Applet;    
import java.awt.*; 

public class Mondrian9 extends Applet {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  int numberRectangles = 100;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    String s = getParameter("Number");
    if (s != null) {
      numberRectangles = Integer.valueOf(s).intValue();
  }
  
    repaint();

  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i &lt; numberRectangles; i++)  {
      RectTop = Randomize(AppletHeight);
      RectLeft= Randomize(AppletWidth);
      RectHeight = Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
  }
  
 }
  
  
  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}
</code></pre>

That's all for now, but we'll return to Mondrian at the end
of this chapter when we add threading, and show how to draw
rectangles continuously.<p></p>

<h6>Exercises</h6>
<ol>
<li>For the artistically inclined: write a version of
Mondrian that draws pictures that are more believably in the
style of Piet Mondrian. You should probably restrict your
color choices and not allow rectangles to overlap.<p>
</p></li></ol>

<h4><a name="xtocid459727">Drawing Lines</a></h4>

The awt contains several graphics primitives. Rectangles are
one and we've pretty much beaten them into the ground in the
previous section.  Lines are another.  Within a graphics
context there is one key line drawing method,
<dfn>drawLine(int x1, int y1, int x2, int y2)</dfn>. This
method draws a straight line between the point (x1, y1) and
the point (x2, y2).  Here's a simple applet that draws a
line diagonally across the applet frame:<p></p>

<pre><code>import java.applet.Applet;    
import java.awt.*; 

public class SimpleLine extends Applet {

  int AppletHeight, AppletWidth;

  public void init() { 
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
  }

 public void paint(Graphics g) {
 
    g.drawLine(0, 0, AppletWidth, AppletHeight);
  
 }

}
</code></pre>


<h5>Graphing Functions</h5>

We're now going to demonstrate the use of the
<code>drawLine()</code> method to draw considerably
non-straight figures. It is shown in advanced calculus that
any reasonably well-behaved (should that be differentiable?)
function can be approximated arbitrarily well by  straight
lines where quantities like &amp;well-behaved" and
"arbitrarily are precisely defined. I'll spare you the
details of the mathematical proof, but I will demonstrate
its probability to you by producing an applet that does a
very good job of graphing any function you care to throw at
it. As usual we'll develop it in pieces rather than just
throwing it all out at once.<p></p>

<p>We begin with the skeleton applet.  We'll need to add some
code to the paint method of the applet to make it draw
something.  Let's begin by drawing a sine wave from the left
hand side of the image to the right hand side. Here's the
complete program:</p>

<pre><code>import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;

  public void init() {
    // How big is the applet?
    Dimension d = size();
  
    x0 = 0;
    xN = d.width-1;
    y0=0;
    yN=d.height-1;
  }
  
  public void paint(Graphics g) {

    for (int x = x0; x &lt; xN; x++) {
      g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1)));
    }

  }
  
}</code></pre>

The meat of this applet is in the for loop of the paint method.<p></p>

<pre><code>    for (int x = x0; x &lt; xN; x++) {
      g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1)));
    }</code></pre>
    
Here we loop across every x pixel of the applet. At each one
we calculate the sine of that pixel.  We also calculate the
sine of the next pixel.  This gives us two 2-D points and we
draw a line between them.  Since the sine of a real number
is always between one and negative one, we scale the y value
by yN.  Finally we cast the y values to ints since sines are
fundamentally floating point values but drawLine requires
ints.<p></p>

<p>This applet runs but it's got a lot of problems.  All of
them can be related to two factors:</p>

<p>
</p></li><li>Sines are floating point operations.  To do a really
useful graphing applet we need to be able to use floating
point numbers.<p>
</p></li><li>The coordinate system of an applet counts from (0,0) at
the upper left hand corner to the right and down.  The
standard Cartesian coordinate system we expect graphs to use
counts from (0,0) in the lower left hand corner to the right
and up.  The origin can be moved in both systems, for
instance to the center of the applet, but we still need to
transform between the y down and the y up coordinates.<p>


There are a number of ways we can resolve this.  The key to
all of them, however, is to separate the data from the
display. Since we are graphing more or less well behaved
mathematical functions, we can assume that our data is
completely described by a rectangle in Cartesian space
within which we wish to plot a function.  The display, on
the other hand, is described by a rectangle of discrete
points of fixed size and width.  We need to be able to
calculate in the general Cartesian plane and display in the
particular applet window.</p>

<p>We'll need a method that will convert a point in the applet
window into a point in the Cartesian plane, and one that
will convert it back.  Here it is:</p>

<pre><code>import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;
  double xmin, xmax, ymin, ymax;
  int AppletHeight, AppletWidth;

  public void init() {
    // How big is the applet?
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth  = d.width;
    x0 = 0;
    xN = AppletWidth-1;
    y0=0;
    yN=AppletHeight-1;
    xmin = -10.0;
    xmax =  10.0;
    ymin = -1.0;
    ymax =  1.0;
  }
  
  public void paint(Graphics g) {
  
    double x1,y1,x2,y2;
    int i, j1, j2;

    j1 = yvalue(0);
    for (i = 0; i &lt; AppletWidth; i++) {
      j2 = yvalue(i+1);
      g.drawLine(i, j1 ,i+1, j2);
      j1 = j2;
    }

  }
  
  private int yvalue(int ivalue)  {
  
    // Given the  xpoint we're given calculate the Cartesian equivalent
    double x, y;
    int jvalue;
    
    x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin;
    
    // Take the sine of that x 
    y = Math.sin(x);
    
    // Scale y into window coordinates
    jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin));
  
    // Switch jvalue from cartesian coordinates to computer graphics coordinates    
    jvalue = AppletHeight - jvalue;
    
    return jvalue;
  
  }


  
}</code></pre>
   

Run this applet.  Isn't that a much nicer looking sine wave?
 There are still a number of things we can add to make this
a more complete applet though.  The most important would be
to add some parameters so that we can define the size of the
applet in HTML.  The following modification of the init and
paint methods looks for xmin, xmax, ymin, and ymax  to be
specified via parameters.  However for robustness if the
author of the HTML forgets to specify them we supply some
reasonable default values.<p></p>

<pre><code>import java.applet.*;    
import java.awt.*; 
              
public class GraphApplet extends Applet {

  int x0, xN, y0, yN;
  double xmin, xmax, ymin, ymax;
  int AppletHeight, AppletWidth;

  public void init() {
    String ParamString;
  
    // How big is the applet?
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth  = d.width;
    x0 = 0;
    xN = AppletWidth-1;
    y0=0;
    yN=AppletHeight-1;    

    ParamString = getParameter("xmin");
    if (ParamString != null) {
      xmin = Double.valueOf(ParamString).doubleValue();
    }
    else {
      xmin = -1.0;
    }
    ParamString = getParameter("xmax");
    if (ParamString != null) {
      xmax = Double.valueOf(ParamString).doubleValue();
    }
    else {
      xmax = 1.0;
    }
    ParamString = getParameter("ymax");
    if (ParamString != null) {
      ymax = Double.valueOf(ParamString).doubleValue();
    }
    else {
      ymax = 1.0;
    }
    ParamString = getParameter("ymin");
    if (ParamString != null) {
      ymin = Double.valueOf(ParamString).doubleValue();
    }
    else {
      ymin = -1.0;
    }
  }

  public void paint(Graphics g) {
  
    double x1,y1,x2,y2;
    int i, j1, j2;

    j1 = yvalue(0);
    for (i = 0; i &lt; AppletWidth; i++) {
      j2 = yvalue(i+1);
      g.drawLine(i, j1 ,i+1, j2);
      j1 = j2;
    }

  }
  
  private int yvalue(int ivalue)  {
  
    // Given the  xpoint we're given calculate the Cartesian equivalent
    double x, y;
    int jvalue;
    
    x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin;
    
    // Take the sine of that x 
    y = Math.sin(x);
    
    // Scale y into window coordinates
    jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin));
  
    // Switch jvalue from cartesian coordinates to computer graphics coordinates    
    jvalue = AppletHeight - jvalue;
    
    return jvalue;
  
  }
  
}</code></pre>
    
Now we can adjust the range over which we graph without
modifying our code!<p></p>

<p>So far we've only graphed sine functions.  It should be
obvious how to modify the code to graph cosines or many
other kinds of functions.  However what if we want to define
the function at runtime?</p>

<p>
</p><h6>Exercises</h6>
<ol>
<li>Add labeled coordinate axes to the graph.<p>
</p></li><li>Our graph method handled mathematical functions.  How
would you need to change it and what features would you add
to make it suitable for plotting discrete experimental
data?<p>
</p></li></ol>

<h5>An infinite set that with zero length</h5>

We're now going to use Java to implement some classic
examples of fractal geometry. We'll do three of these.  We
begin with a one-dimensional set with an infinite number of
points that covers zero length.  Then we'll investigate the
Koch snowflake.  Finally in the next chapter we'll delve
into the most famous fractal of all, the Mandelbrot set.<p></p>

<p>The middle third set is defined by starting with all the
real numbers between zero and one inclusive. Then we cut out
the middle third of that set (exclusive of the endpoints).
i.e. everything between one third and two thirds
exclusive.</p>

<p>Next we cut the middle third of the two line segments that
remain, i.e. everything between one ninth and two ninths and
between seven ninths and eight ninths.  We continue this
process indefinitely.</p>

<p>Was that confusing? Good.  A picture is worth a thousand
words and a good Java program is worth a thousand pictures.
We now proceed to show you a Java program that draws
successive pictures to demonstrate the middle third set.</p>

<pre><code>
import java.applet.Applet;    
import java.awt.*;
import java.util.Vector;

public class MiddleThird extends Applet {

int AppletWidth;
int AppletHeight;

Vector endpoints = new Vector();

  public void init() { 
    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    endpoints.addElement(new Float(0.0f));
    endpoints.addElement(new Float(1.0f));  
  }

 public void paint(Graphics g) {
 
   float x1, x2;
   Float tempFloat;
   for (int i = 0; i &lt;  AppletHeight; i+= 5) {
     // draw the lines
     for (int j=0; j &lt; endpoints.size(); j += 2) {
       tempFloat = (Float) endpoints.elementAt(j);
       x1 = tempFloat.floatValue();
       tempFloat = (Float) endpoints.elementAt(j+1);
       x2 = tempFloat.floatValue();
       g.drawLine( Math.round(x1*AppletWidth), i, Math.round(x2*AppletWidth), i);
     }
     //remove the middle third of the lines
     CutSegments();
     // Now check to see if we've exceeded the resolution of our screen
     tempFloat = (Float) endpoints.elementAt(0);
     x1 = tempFloat.floatValue();
     tempFloat = (Float) endpoints.elementAt(1);
     x2 = tempFloat.floatValue();
     if (Math.round(x1*AppletWidth) == Math.round(x2*AppletWidth)) break;
   }
  
   
 }

 private void CutSegments() {

   int index = 0;
   float gap;
   float x1, x2;
   Float tempFloat1, tempFloat2;
   int stop = endpoints.size();
   
   for (int i=0; i &lt; stop; i+=2) {
      CutMiddleThird(index, index+1);
      index += 4;
   }
   
 }
 
 
  private void CutMiddleThird(int left, int right) {

   float gap;
   float x1, x2;
   Float tempFloat1, tempFloat2;
   
   tempFloat1 = (Float) endpoints.elementAt(left);
   tempFloat2 = (Float) endpoints.elementAt(right);
   gap = tempFloat2.floatValue() - tempFloat1.floatValue();
   x1  = tempFloat1.floatValue() + gap/3.0f;
   x2  = tempFloat2.floatValue() - gap/3.0f;
   endpoints.insertElementAt(new Float(x2), right);
   endpoints.insertElementAt(new Float(x1), right);
   
 }

}
</code></pre>


Compile and load this applet. Is that clearer?  Of course
this isn't a perfect representation of the middle third set
since we have to deal with points of finite size rather than
with genuine mathematical points.  Depending on how large  a
window you give your applet, you will probably only see
about six to twelve iterations before we need to start
working with fractional pixels.<p></p>

<p></p><h5>Flying Lines</h5>

The next example is harder to describe than it is 
to code.  Like Mondrian it runs in an infinite loop
but it's a little more than random images.  Compile the following code, run it and then look
over the code to see if you can understand the algorithm.<p></p>

<pre><code>//Bounce lines around in a box

import java.applet.Applet;    
import java.awt.*; 
        
public class FlyingLines extends Applet {

  int NUM_LINES = 25;
  int gDeltaTop=3, gDeltaBottom=3;
  int gDeltaLeft=2, gDeltaRight=6;
  int AppletWidth, AppletHeight;
  int gLines[][] = new int[NUM_LINES][4];

  public void init() {

    AppletWidth = size().width;
    AppletHeight = size().height;

  }
  
  public void start() {
    gLines[0][0] = Randomize(AppletWidth);
    gLines[0][1] = Randomize(AppletHeight);
    gLines[0][2] = Randomize(AppletWidth);
    gLines[0][3] = Randomize(AppletHeight);
    for (int i=1; i &lt; NUM_LINES; i++ ) {
      LineCopy(i, i-1);
      RecalcLine(i);
    } 
    repaint();
  
  }

  public void paint(Graphics g) {

     while (true) {
      for (int i=NUM_LINES - 1; i &gt; 0; i--) {
        LineCopy(i, i-1);
      }
      RecalcLine(0);
      g.setColor(Color.black);
      g.drawLine(gLines[0][0], gLines[0][1], gLines[0][2], gLines[0][3]);
      g.setColor(getBackground());
      g.drawLine(gLines[NUM_LINES-1][0], gLines[NUM_LINES-1][1], 
        gLines[NUM_LINES-1][2], gLines[NUM_LINES-1][3]);
    }
    
  }

  private void LineCopy (int to, int from)  {

    for (int i = 0; i &lt; 4; i++) {
      gLines[to][i] = gLines[from][i];
    }

  }

  public int Randomize( int range ) {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

  private void RecalcLine( int i ) {

    gLines[i][1] += gDeltaTop;
    if ((gLines[i][1] &lt; 0) || (gLines[i][1] &gt; AppletHeight)) {
      gDeltaTop *= -1;
      gLines[i][1] += 2*gDeltaTop;
    }

    gLines[i][3] += gDeltaBottom;
    if ( (gLines[i][3] &lt; 0) || (gLines[i][3] &gt; AppletHeight) ) {
      gDeltaBottom *= -1;
      gLines[i][3] += 2*gDeltaBottom;
    }

    gLines[i][0] += gDeltaLeft;
    if ( (gLines[i][0] &lt; 0) || (gLines[i][0] &gt; AppletWidth) ) {
      gDeltaLeft *= -1;
      gLines[i][0] += 2*gDeltaLeft;
    }

    gLines[i][2] += gDeltaRight;
    if ( (gLines[i][2] &lt; 0) ||  (gLines[i][2] &gt; AppletWidth) ) {
      gDeltaRight *= -1;
      gLines[i][2] += 2*gDeltaRight;
    }
    
  }  //RecalcLine ends here

} // FlyingLines ends here
</code></pre>

<h3><a name="xtocid459732">Taking Action: Threads</a></h3>

Depending on your operating system and Java-enabled browser
you may have noticed that the Mondrian and Flying Line
programs tended to hog your CPU.  On Windows NT HotJava
stopped responding to my commands several thousand
iterations into Mondrian, and I had to kill it from the Task
List.<p></p>

<p>The paint loops in both Mondrian and FlyingLines are ideal
for a <dfn>thread</dfn>, a separate stream of execution that
takes place simultaneously and independently of everything
else that might be happening (like responding to the
programmer's insistence to "Quit!, Damnit!"). 
Without threads an entire program can be held up by one CPU
intensive task or, as in Flying Lines, one infinite loop,
intentional or otherwise.</p>

<p>As a general rule all CPU intensive tasks should be placed
in their own threads.  Here's one way to do it.</p>

<pre><code>//Draw infinitely many random rectangles

import java.applet.Applet;    
import java.awt.*; 

public class ThreadedMondrian extends Applet implements Runnable {

  int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight;
  Color RectColor;
  Thread kicker = null;
  int pause;
  
  public void init() {

    Dimension d = size();
    AppletHeight = d.height;
    AppletWidth = d.width;
    repaint();
  }

  public void paint(Graphics g) {
  
    g.setColor(Color.black);
    g.drawRect(0, 0, AppletWidth-1, AppletHeight-1);
   
    for (int i=0; i &lt; 10; i++) {
      RandomRect();
      g.setColor(RectColor);
      g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1);
    } 
  
 }
  
  public void run() {
    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

    while (true) {  // infinite loop
      repaint();
      try {
        Thread.sleep(100);
       }
       catch (Exception e) {
       
       }
    }
  }

  public void start() {
    if (kicker == null) {
      kicker = new Thread(this);
      kicker.start();
    }
  }

  public void stop() {
    kicker = null;
  }

  public void RandomRect()  {
      RectTop   = Randomize(AppletHeight);
      RectLeft  = Randomize(AppletWidth);
      RectHeight= Randomize(AppletHeight - RectTop);
      RectWidth = Randomize(AppletWidth - RectLeft);
      RectColor = new Color(Randomize(255),Randomize(255),Randomize(255));
  }

  private int Randomize(int range)
  {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

}</code></pre>


<p>We added four key things to Mondrian to make it threaded and a lot more CPU friendly.</p>

<p>
</p></li><li>We specified that our applet implements Runnable.
</li><li>We added a run method.
</li><li>We added a start method.
</li><li>We added a stop method.
<p></p>

<p>Let's look at them in more detail:</p>

<dl>
<dt>Our applet implements Runnable
</dt><dd>

<p>
</p></dd><dt>Run Method
</dt><dd>
</dd><dt>Start Method
</dt><dd>
</dd><dt>Stop Method
</dt><dd>

</dd></dl>


<p>Here's a threaded version of Flying Lines.</p><p>
</p><pre><code>//Bounce lines around in a box

import java.applet.Applet;    
import java.awt.*; 
        
public class FlyingLines extends Applet implements Runnable {

  int NUM_LINES = 25;
  int gDeltaTop=3, gDeltaBottom=3;
  int gDeltaLeft=2, gDeltaRight=6;
  int AppletWidth, AppletHeight;
  int gLines[][] = new int[NUM_LINES][4];

  public void init() {

    AppletWidth = size().width;
    AppletHeight = size().height;

  }
  
  public void start() {
    gLines[0][0] = Randomize(AppletWidth);
    gLines[0][1] = Randomize(AppletHeight);
    gLines[0][2] = Randomize(AppletWidth);
    gLines[0][3] = Randomize(AppletHeight);
    for (int i=1; i &lt; NUM_LINES; i++ ) {
      LineCopy(i, i-1);
      RecalcLine(i);
    } 
    repaint();
    Thread t = new Thread(this);
    t.start();
  
  }

  public void run () {
  
    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
  
    while (true) {
      for (int i=NUM_LINES - 1; i &gt; 0; i--) {
        LineCopy(i, i-1);
      }
      RecalcLine(0);
      System.out.println(gLines[0][0] + ", " + gLines[0][1] + "," + gLines[0][2] + ", " + gLines[0][3]);
      repaint();
      try {
        Thread.currentThread().sleep(10);
      }
      catch (Exception e) {
      
      }
    }
  
  }

  public void paint(Graphics g) {

    for (int i=0; i &lt; NUM_LINES; i++) {
      g.drawLine(gLines[i][0], gLines[i][1], gLines[i][2], gLines[i][3]);
    }
    
  }

  private void LineCopy (int to, int from)  {

    for (int i = 0; i &lt; 4; i++) {
      gLines[to][i] = gLines[from][i];
    }

  }

  public int Randomize( int range ) {
    double  rawResult;

    rawResult = Math.random();
    return (int) (rawResult * range);

  }

  private void RecalcLine( int i ) {

    gLines[i][1] += gDeltaTop;
    if ((gLines[i][1] &lt; 0) || (gLines[i][1] &gt; AppletHeight)) {
      gDeltaTop *= -1;
      gLines[i][1] += 2*gDeltaTop;
    }

    gLines[i][3] += gDeltaBottom;
    if ( (gLines[i][3] &lt; 0) || (gLines[i][3] &gt; AppletHeight) ) {
      gDeltaBottom *= -1;
      gLines[i][3] += 2*gDeltaBottom;
    }

    gLines[i][0] += gDeltaLeft;
    if ( (gLines[i][0] &lt; 0) || (gLines[i][0] &gt; AppletWidth) ) {
      gDeltaLeft *= -1;
      gLines[i][0] += 2*gDeltaLeft;
    }

    gLines[i][2] += gDeltaRight;
    if ( (gLines[i][2] &lt; 0) ||  (gLines[i][2] &gt; AppletWidth) ) {
      gDeltaRight *= -1;
      gLines[i][2] += 2*gDeltaRight;
    }
    
  }  //RecalcLine ends here

} // FlyingLines ends here
</code></pre>


<h4><a name="xtocid459733">Bozo Sort</a></h4>

<p>Some of the first compelling Java demos were <a href="http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html">graphical
illustrations of several sorting methods</a> including quick
sort, bubble sort and bidirectional bubblesort intended to
show off the threading capabilities of Java.  That's nice,
but those methods eventually succeed within our lifetime. 
For an applet that truly puts threading to good use consider
the following <dfn>bozo sort</dfn>.  In bozo sort the same
collection of differently sized sticks is thrown up in the
air.  If they land in sorted order, the algorithm stops. 
Otherwise we throw all the sticks in the air again.  This
algorithm runs in about O(N!) time where N is the number of
sticks.  It takes effectively infinite time for more than a
dozen or so sticks.  It's a horrible algorithm but a really
great opportunity for threading.</p>

<pre><code>
class BozoSortAlgorithm extends SortAlgorithm {

  void sort(int a[]) {
    
    boolean sorted = false;
    
    while (!sorted) {
      int index1 = Randomize(a.length);
      int index2 = Randomize(a.length);  
     
      int temp = a[index2];
      a[index2] = a[index1];
      a[index1] = temp;
      // Is a[] sorted?
      sorted = true;
      for (int i = 1; i &lt; a.length; i++)  {
        if (a[i-1] &gt; a[i]) {
          sorted = false;
          break;
        }  // end if
      }  // end for
    } // end while
  }  // end sort 
   
  private int Randomize( int range )  {

    double  rawResult;
  
    rawResult = Math.random();
    return (int) (rawResult * range);

  }
  
}  // end BozoSortAlgorithm
</code></pre>

<p>To actually run this you'll also need the 
<a href="http://www.cs.ubc.ca/spider/harrison/Java/SortItem.java">SortItem</a> 
and 
<a href="http://www.cs.ubc.ca/spider/harrison/Java/SortAlgorithm.java">SortAlgorithm</a> 
classes from Sun.</p>

<h3><a name="xtocid459734">Interaction: Mouse and Keyboard Input</a></h3>

<p>You now have the tools to draw a lot of really cool
animations and images on your web pages.  This alone puts
you leaps and bounds beyond the average web page designer. 
Still that's only half the point of applets.  The other half
is interaction with the user.  Your applets can accept input
from the user and respond to them.  For the first time a web
surfer can move beyond mere browsing to genuine
participation.</p>

<h4><a name="xtocid126145">Mouse Input: Java Doodle</a></h4>


<p>Here's a simple applet that lets you doodle with the mouse on an applet.</p>

<pre><code>import java.applet.Applet;
import java.awt.*;
import java.util.Vector;

public class JavaDoodle extends Applet {

  Vector points = new Vector();

  
  public void paint(Graphics g) {
  
  	int x1, y1, x2, y2;
  	Point tempPoint;
  
    if (points.size() &gt; 1) {
      tempPoint = (Point) points.elementAt(0);
	  x1 = tempPoint.x;
	  y1 = tempPoint.y;
      for (int i = 1; i &lt; points.size(); i++) {
    	tempPoint = (Point) points.elementAt(i);
	  	x2 = tempPoint.x;
	  	y2 = tempPoint.y;
    	g.drawLine(x1, y1, x2, y2);
    	x1 = x2;
    	y1 = y2;
      } // end for
    } // end if
  }
  
  public boolean mouseDown(Event e, int x, int y) {
    points.addElement(new Point(x, y));
  	return true;
  }

  public boolean mouseDrag(Event e, int x, int y) {
    points.addElement(new Point(x, y));
    repaint();
  	return true;
  }

  public boolean mouseUp(Event e, int x, int y) {
    points.addElement(new Point(x, y));
    repaint();
  	return true;
  }



}
</code></pre>

<h6>Exercises</h6>
<ol>
<li>Revise the applet so that it doesn't draw
a line between the point where the mouse button was
released and the point where it was pressed again.  
</li></ol>


<h4><a name="xtocid126146">Keyboard Input: TypeWriter</a></h4>

Here's a simple applet that uses the keyDown method to let you type some text.<p>
</p><pre><code>import java.applet.Applet;    
import java.awt.Event; 
import java.awt.Graphics; 

public class typewriter extends Applet {

  int numcols = 80;
  int numrows = 25;
  int row = 0;
  int col = 0;
  char page[][] = new char[numrows][];

  public void init() {

        for (int i = 0; i &lt; numrows; i++) {
      page[i] = new char[numcols];
    }
    for (int i = 0; i &lt; numrows; i++) {
    	for (int j = 0; j &lt; numcols; j++) {
    	  page[i][j] = '\0';
    	}
    }

  }
  
  
  public boolean keyDown(Event e, int key) {
 
    char c = (char) key;

    switch (key) {
      case Event.HOME:
        row = 0;
        col = 0;
        break;
      case Event.END:
        row = numrows-1;
        col = numcols-1;
        break;
      case Event.UP:
        if (row &gt; 0) row--;
        break;
      case Event.DOWN:
        if (row &lt; numrows-1) row++;
        break;
      case Event.LEFT:
        if (col &gt; 0) col--;
        else if (col == 0 &amp;&amp; row &gt; 0) {
          row--;
          col=numcols-1;
        }
        break;
      case Event.RIGHT:
        if (col &lt; numcols-1) col++;
        else if (col == numcols-1 &amp;&amp;  row &lt; numrows-1) {
          row++;
          col=0;
        }
        break;
      default:
        if (c == '\n' || c == '\r') {
          row++;
          col = 0;
        }
        else if (row &lt; numrows) {
          if (col &gt;= numcols) {
    	    col = 0;
    	    row++;
          }
          page[row][col] = c;
          col++;
        }
   	    else { // row &gt;= numrows
   	     col++;
   	    }
   	 }
   	 repaint();
   	 return true;
  } 


  public void paint(Graphics g) {

	for (int i=0; i &lt; numrows; i++) {
	  String tempString = new String(page[i]);	      
      g.drawString(tempString, 5, 15*(i+1));
    }
    
  }

}</code></pre>



<h2><a name="xtocid459735">Part 4:  Objects, Classes, Methods, and Interfaces</a></h2>

<h3><a name="xtocid499464">What is Object Oriented Programming?</a></h3>

<p>Object Oriented Programming is the programming buzzword of the 90's. 
Everyone and everything advertises their products as
object-oriented. But what does object oriented mean? To
understand why object oriented programming is so
revolutionary, let's take a brief glance back at the history
of computing.</p>

<h4><a name="xtocid2801972">The History of Programming</a></h4>

<p>Programming has always been guided by various methodologies.
In the early days of computers, computer memories were quite
small. Programs had to be loaded in by toggling switches on
a panel. In these days it was possible for a programmer to
keep track of every memory location and every machine
instruction in his or her head.  Since computer memories
were so small (often just a few hundred bytes) and the
machines so slow, program efficiency was the primary
concern. Any program was acceptable as long as it worked.
Algorithms were very closely tied to the capabilities of the
specific machine they ran on. This is called machine
language programming. The toggling of individual memory
locations (by switch or other means) is called a
<dfn>first-generation language</dfn>, and we're being very
liberal with the definition of language.  In a first
generation language there is almost no abstraction.</p>

<p>As computers grew in power and memory, it was no longer
possible for a programmer to keep track of what was
happening at every location in the machine's physical
memory.  Card readers and assembly language were invented to
make programming more feasible. In assembly language the
programmer uses mnemonic codes like MOV to represent
particular bit sequences.  These codes mapped directly to
individual instructions on the CPU, and memory was still
addressed directly. One code meant exactly one CPU
instruction. <footnote>(More modern assembly languages don't
always map as directly to the CPU as the older ones
did.)</footnote> Algorithmically The philosophy of "Use
whatever works" continued.  </p>

<p>Assembly language was still a bear to deal with, especially
as related to arrays and storage in memory.  Therefore the
first high-level programming language, Fortran, was invented
to spare programmers from the pains of dealing with keeping
track of the location of their variables in memory. 
<footnote>(It's interesting to note that this lesson has had
to be learned again and again and again.  The buggiest parts
of C and C++ programs result from programmers being allowed
to access arbitrary bytes of memory.  Java has wisely
removed this capability. 99 times out of a 100 you don't
need it.  A large part of training a C or C++ programmer to
use Java, consists of convincing them of this
fact.)</footnote>. Fortran was the first example of a
third-generation language.  In a third generation language
you tell the computer the algorithms and data structures it
should use to calculate the results you want; but you use
more abstract logical and mathematical operators rather than
directly manipulating addresses in memory and CPU
instructions. In a third generation language, statements
represent several machine instructions. Which instructions
they represent may even depend on their context.</p>

<p>These languages may be compiled or interpreted. In either
case your program code needs to be translated into
equivalent machine instructions. This level of abstraction
made considerably more powerful algorithms and data
structures possible. </p>

<p>Java is a very advanced third generation language. Most of
the other computer languages you're probably familiar with,
Fortran, Basic, C, C++, Cobol, Pascal, as well as most of
the one's you're not familiar with (AppleScript, Frontier,
Eiffel, Modula-3, ADA, PL/I, etc.) are also third-generation
languages (or 3GL's for short).</p>

<p>When third generation languages were invented, they were
supposed to make computers so easy to use even the CEO could
write programs. This turned out not to be true.  Fourth
generation languages (or 4GL's for short) moved the
abstraction level a step higher. In these languages you tell
the computer what results you want rather telling it how to
calculate those results. For instance you would ask for the
total sales for the year, without specifying the loops
necessary to sum all the sales of all the salespeople. SQL
is the most popular fourth generation language.</p>

<p>Of all these languages there's no question that 3GL's have
been the most successful by almost any measure. A number of
different styles of 3GL programming and programming
languages have sprung up, most learning from the experience
and mistakes of its predecessors.  Fortran (and its  cousin
Basic) were the first. They shared with assembly language an
attitude of "Whatever works, no matter how ugly."
They had limited flow control (essentially for loops and
goto statements) and one data structure, the array. All
variables were global and it was impossible to hide one part
of the program from any other. Although it was possible to
write maintainable, legible code in these languages, few
people did.</p>

<p>Pascal and C were the next widely successful languages. They
made possible a style of programming known as
<dfn>structured programming</dfn>. Structured programming
languages have many different flow control constructs
(switch statements, while loops, and more) as well as tools
for more complicated data structures (structs, records and
pointers). Goto is deprecated in structured programming
though not eliminated entirely.  (It is still necessary for
some error handling.) Finally they have subroutines with
local variables that are capable of splitting the code into
more manageable and understandable chunks.  These languages
proved more capable of writing larger, more maintainable
programs. However they too began to bog down when faced with
the need to share code among programmers and to write very
large (greater than 50,000 line) programs.</p>

<p>Some of the above history may sound a little funny to those
of you with experience in the languages I'm discussing. 
After all Basic has subroutines and local
variables, doesn't it?  The fact is successful computer
languages have continued to evolve.  Fortran now has
pointers so it can create more complicated data structures. 
Basic has while loops.  Cobol has objects. And on some
architectures like Alpha/VMS the assembly language bears
little to no resemblance to the underlying machine
architecture. These features were not parts of the first
versions of the language, however. And despite these
improvements the modern versions of these languages are
their parents children. Basic and Fortran programmers still
often produce spaghetti code.  Assembly language is quick to
run but long to program.  C is obfuscated beyond the
comprehension of mere mortals.</p>

<p>The third generation of 3GL's (3.3 GL's) began to take hold
in the late 80's. These were the object oriented languages. 
Although object oriented languages had been around since the
late 1960's, it wasn't until the late 80's that computer
hardware became fast enough and memory cheap enough to
support them. <footnote>(Object oriented programming is not
a panacea.  It exacts a speed penalty over plain vanilla C
or Fortran code, and often requires twice as much
memory.)</footnote></p>

<p>Object oriented languages (OOP for short) included all the
features of structured programming and added still more
powerful ways to organize algorithms and data structures. 
There are three key features of OOP languages:
encapsulation, polymorphism and inheritance. All of them are
tied to the notion of a class.</p>

<h4><a name="xtocid499465">Classes and Objects</a></h4>

<p>The primary distinguishing feature of OOP languages is the
class. A class is a data structure that can associate the
methods which act on an object with the object itself. In
pre-OOP languages methods and data were separate. In OOP
languages they are all part of classes.</p>

<p>Programming languages provide a number of simple data types
like int, float and String. However very often the data you
want to work with may not be simple ints, floats or Strings.
 Classes let programmers define their own more complicated
data types.</p>

<p>For instance let's suppose your program needs to keep a
database of web sites.  For each site you have a name, a
URL, and a description.  In traditional programming
languages you'd have three different String variables for
each web site. With a class you combine these into one
package like so:</p>

<pre><code>class website {

  String name;
  String url;
  String description;

}
</code></pre>

<p>These variables (name, url and description) are called the
<dfn>members</dfn> of the class. They tell you what a class
is and what its properties are. They are the nouns of the
class.</p>

<p>In our web site database we will have many thousands of
websites. Each specific web site is an object. The
definition of a web site though, which we gave above, is a
class. This is a very important distinction.  A class
defines what an object is, but it is not itself an object. 
An object is a specific <dfn>instance</dfn> of a class. Thus
when we create a new object we say we are
<dfn>instantiating</dfn> the object. Each class exists only
once in a program, but there can be many thousands of
objects that are instances of that class.</p>

<p>To instantiate an object in Java we use the <code>new</code>
operator.  Here's how we'd create a new web site:</p>

<pre><code>
    website x = new website();
</code></pre>

Once we've got a website we want to know something about it.
 To get at the member variables of the website we can use
the <code>.</code> operator. Website has three member
variables, name, url and description, so x has three member
variables as well, x.name, x.url and x.description. We can
use these just like we'd use any other String variables. For
instance:<p></p>

<pre><code>
    website x = new website();
    
    x.name = "Cafe Au Lait";
    x.url = "http://metalab.unc.edu/javafaq/";
    x.description = "Really cool!";
    
    System.out.println(x.name + " at " + x.url + " is " + x.description);
</code></pre>

<h4><a name="xtocid2801974">Methods</a></h4>

Data types aren't much use unless you can do things with them. For this purpose classes have methods.
Members say what a class is. Methods say what a class does. For instance our website class
might have a method to print its data.  If so that would look like this:<p></p>

<pre><code>class website {

  String name;
  String url;
  String description;
  
  print() {
    System.out.println(name + " at " + url + " is " + description);
  }

}
</code></pre>

Outside the website method we call the print method just
like we referenced the member variables, using the name of
the particular object we want to print and the
<code>.</code> operator.<p></p>

<pre><code>
    website x = new website();
    
    x.name = "Cafe Au Lait";
    x.url = "http://metalab.unc.edu/javafaq/";
    x.description = "Really cool!";
    
    x.print();
</code></pre>

Notice that within the website class we don't need to use
x.name or x.url.  name and url are sufficient. That's
because the print method must be called by a specific
instance of the website class, and this instance knows what
its data is. Or, another way of looking at it, the every
object has its own print method. <p> The print() method is
completely enclosed within the website class. All methods in
Java must belong to a class. Unlike C++ programs, Java
programs cannot have a method hanging around in global space
that does everything you forgot to do in your classes.</p>

<p>
</p><h5>Constructors</h5>

The first method most classes need is a
<dfn>constructor</dfn>.  A constructor creates a new
instance of the class.  It initializes all the variables and
does any work necessary to prepare the class to be used.  In
the line  <code>website x = new website();</code> website()
is a constructor.  If no constructor exists Java provides a
default one, but it's better to make sure you have your own.
You make a constructor by writing a public method that has
the same name as the class.  Thus our website constructor is
called website(). Here's a revised website class with a
constructor that initializes all the members to null
Strings.<p></p>

<pre><code>class website {

  String name;
  String url;
  String description;
  
  public website() {
    name = ""; 
    url  = "";
    description = "";
  }

}
</code></pre>

Better yet, we should create a constructor that accepts
three Strings as arguments and uses those to initialize the
member variables like so:<p></p>

<pre><code>class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

}
</code></pre>

We'd use this like so:<p></p>

<pre><code>
    website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!");
    x.print();
</code></pre>


This fits in well with the goal of keeping code relevant to
the proper functioning of a class within the class.<p></p>

<p>However what if sometimes when we want to create a web site
we know the URL, name, and description, and sometimes we
don't? Best of all, let's use both!</p>

<pre><code>class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

  public website() {
    name = ""; 
    url  = "";
    description = "";
  }

}
</code></pre>


This is called <dfn>method overloading</dfn> or
<dfn>polymorphism</dfn>. Polymorphism is a feature of object
oriented languages that lets one name refer to different
methods depending on context.  The important context is
typically the number and type of arguments to the method. 
In this case we use the first version of the method if we
have three String arguments and the second version if we
don't have any arguments.<p></p>

<p>If you have one or two or four String arguments to the
constructor, or arguments that aren't Strings, then the
compiler generates an error because it doesn't have a method
whose <dfn>signature</dfn> matches the requested method
call.  </p>

<p></p><h5>toString Methods</h5>

Print methods are common in some languages but most Java
programs operate differently.  You can use
<code>System.out.println()</code> to print any object. However for good
results your class should have a <code>toString()</code> method that
formats the objects data in a sensible way and returns a
String. Here's how we'd implement it in the <code>website</code>
example: <p></p>

<pre><code>public class ClassTest {

  public static void main(String args[]) {
  
    website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!");
    System.out.println(x);
  
  }

}


class website {

  String name;
  String url;
  String description;
  
  public website(String n, String u, String d) {
    name = n; 
    url  = u;
    description = d;
  }

  public website() {
    name = ""; 
    url  = "";
    description = "";
  }
  
  public String toString() {
    return  (name + " at " + url + " is " + description);
  }

}</code></pre>



<h4><a name="xtocid2801977">Some Advocacy</a></h4>

Unfortunately the object oriented language that took hold
was C++. Among much fitter contenders for object languages,
notably Smalltalk, C++ had the unique advantage of being
downward compatible with the C programmers were already
familiar with. Unfortunately this advantage had the huge
side effect of forcing C++ to accept all of C's obfuscated
macros, pointer arithmetic, and now redundant structs. The
baggage imposed on C++ by the need to be compatible with C
went a long way toward wiping out the advantage of object
oriented programming.<p></p>

<p>Java is the latest and possibly the greatest third
generation programming language.  Here I need to explain why
Java is a better OOP language than C++.</p>

<p></p><h3><a name="xtocid900031">A Non-Trivial Examples: Complex Numbers</a></h3>

As mentioned in Chapter 2 one of the features needed for
serious scientific computation is complex numbers. 
Unfortunately no popular computer language other than Fortran provides them
as a built-in data type.  (Actually this is such a common
and useful example and was used by so many textbooks that it
was recently added to the C++ standard library which makes
it far less useful as an example.  Fortunately, however,
Java has not yet been around long enough to have all its
really useful examples coopted into the standard library.)
Let's see how we might implement them in Java.  From the
standpoint of a data type you really don't need much. 
Mathematically a complex number is composed of a real part u
and an imaginary part v.  We can create such a class in the
following way:<p></p>

<pre><code>public class ComplexNumber extends Object {

  public double u;
  public double v;

}</code></pre>

While this is sufficient to encompass all the data that one needs in
a complex number it's not a very good example of object-oriented programming.
To actually do anything with this number we have to know exactly how the 
data structure is defined.  If we change the data structure, for instance by
defining a complex number in terms of it's magnitude r and its argument theta 
instead of by its real and imaginary components 
we have to change all the code that depends on it.<p>
We also have to write code to explicitly add the numbers, multiply them or
do anything else we might need to do with complex numbers.  If we need to 
add complex numbers in more than one place, then we need to write the
addition code again, or, at the very least, copy
and paste it.</p>

<p>A better implementation of a complex number class will shield us from the exact
storage of the data, i.e. x and y vs. r and theta.  It will also
provide methods that let us perform any operation we might need to perform
on or with a complex number.</p>

<p>Before writing code we need to ask ourselves what we'll do with a complex number.
Most objects first require a <dfn>constructor</dfn>, a method that is called
when you create a new complex number.  A more complicated object
may also require a <dfn>destructor</dfn> method that's called when you
get rid of an object; but since this is a fairly simple object, we'll
let Java's built-in garbage collection take care of that for us.</p>

<p>Since these are complex <em>numbers</em> it's not unlikely that we'll
need to add them, subtract them, multiply them and divide them.  We'll
also want to be able to access their real and imaginary parts as well
as their absolute values and arguments.  The following class
does all that.</p><p>
 
</p><pre><code>//
public class Complex extends Object {

  private double u;
  private double v;

  Complex (double x, double y) {

    u=x;
    v=y;

  }

  public double Real () {

    return u;

  }

  public double Imaginary () {

    return v;

  }

  public double Magnitude () {

    return Math.sqrt(u*u + v*v);

  }

  public double Arg () {

    return Math.atan2(v, u);

  }

  // Add z to w; i.e. w += z
  public Complex Plus (Complex z) {

    
    return new Complex(u + z.u, v + z.v);

  }

  // Subtract z from w
  public Complex Minus (Complex z) {

    return new Complex(u - z.u, v - z.v);

  }

  public Complex Times (Complex z) {

    return new Complex(u*z.u - v*z.v, u*z.v + v*z.u);
    
  }


  // divide w by z
  public Complex DivideBy (Complex z) {

    double rz = z.Magnitude(); 

    return new Complex((u * z.u + v * z.v)/(rz*rz),(v * z.u - u * z.v)/(rz*rz));

  }

}</code></pre>


<p>Notice especially that <code>u</code> and <code>v</code> are now private.  They cannot be accessed
by external code even if we want them to be. </p>

<p>The use of one of these
methods will look like the following.  Add the following <code>ComplexExamples</code>
class to the Complex.java file and compile.  Then run <code>ComplexExamples</code> in the
usual way by typing <kbd>java ComplexExamples</kbd>.</p>

<pre><code>//Complex Arithmetic Examples
class ComplexExamples  {

  public static void main (String args[]) {
  
    Complex u, v, w, z;

    u = new Complex(1,2);
    System.out.println("u: " + u.Real() + " + " + u.Imaginary() + "i");
    v = new Complex(3,-4.5);
    System.out.println("v: " + v.Real() + " + " + v.Imaginary() + "i");
    
    // Add u + v;
    z=u.Plus(v);
    System.out.println("u + v: "+ z.Real() + " + " + z.Imaginary() + "i");
    // Add v + u;
    z=v.Plus(u);
    System.out.println("v + u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.Minus(v);
    System.out.println("u - v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.Minus(u);
    System.out.println("v - u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.Times(v);
    System.out.println("u * v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.Times(u);
    System.out.println("v * u: "+ z.Real() + " + " + z.Imaginary() + "i");

    z=u.DivideBy(v);
    System.out.println("u / v: "+ z.Real() + " + " + z.Imaginary() + "i");
    z=v.DivideBy(u);
    System.out.println("v / u: "+ z.Real() + " + " + z.Imaginary() + "i");

  }

}</code></pre>


<h6>Exercises</h6>

<ol>
<li>What happens if we try to add a complex number to itself? e.g.<p>
</p><pre><code>
z = u.Add(u);
</code></pre>
How about if we multiply, divide or subtract? e.g.<p>
</p><pre><code>
z = u.Multiply(u);
z = u.Divide(u);
z = u.Minus(u);
</code></pre>
</li><li> Rewrite the Complex  class so that it stores its data as
r and theta rather than u and v.  Be sure to be careful
at zero.
</li><li>Add PlusEqual, MinusEqual, DivideEqual and MultiplyEqual methods to
the Complex class that mimic the behavior of the +=, -=, *= and /= operators.
</li><li>Add an equality method to the Complex class that tests whether two complex numbers are equal
and returns a boolean.
</li><li>For math whizzes only: Explain why it would <strong>not</strong> be a good idea to add
less than or greater than methods to the Complex class.
</li><li>For math whizzes only: Add a logarithm method to the Complex number class.
Pick the branch between zero and 2pi.
</li><li>For math whizzes only: Add a power method to the complex number class.  This is
straightforward for real powers. For a real challenge allow
arbitrary complex powers.  Be sure to consider how you'll deal with 
branch cuts.
</li></ol>

<h4><a name="xtocid2801984">toString Methods</a></h4>

Our printing in the last program was quite stilted because we needed to break
a complex number into its real and imaginary parts, print them, and then put it all
back together again.  Wouldn't it be nice if we could just write:<p></p>

<p><code>System.out.println(u);</code></p>

<p>instead?  It turns out we can. All objects have a toString
method which is inherited from the Object class.  However
the default toString() method isn't very useful so we want
to override it with one of our own creation that handles the
conversion to complex numbers.  Add the following method to
the Complex class:</p>

<pre><code>  public String toString() {
  
    if (v &gt;= 0) return (String.valueOf(u) + " + " + String.valueOf(v) + "i");
    else return (String.valueOf(u) + " - " + String.valueOf(-v) + "i");
  }</code></pre>
  
  <p>You should also modify the ComplexExamples class as follows:</p><p>
</p><pre><code>
class ComplexExamples  {

  public static void main (String args[]) {
  
    Complex u, v, z;

    u = new Complex(1,2);
    System.out.println("u: " + u);
    v = new Complex(3,-4.5);
    System.out.println("v: " + v);
    
    // Add u + v;
    z=u.Plus(v);
    System.out.println("u + v: " + z);
    // Add v + u;
    z=v.Plus(u);
    System.out.println("v + u: " + z);


    z=u.Minus(v);
    System.out.println("u - v: " + z);
    z=v.Minus(u);
    System.out.println("v - u: " + z);

    z=u.Times(v);
    System.out.println("u * v: " + z);
    z=v.Times(u);
    System.out.println("v * u: "+ z);

    z=u.DivideBy(v);
    System.out.println("u / v: " + z);
    z=v.DivideBy(u);
    System.out.println("v / u: " + z);

  }
  
}</code></pre>

<p>That's about an order of magnitude easier to understand and to write.</p>

<h4><a name="xtocid2801985">Polymorphism</a></h4>

<p>So far our methods just do arithmetic on two complex numbers.
It's not uncommon to want to multiply a complex number by a real number.
To add this capability to our
class we'll add the following method:</p>

<pre><code> 
  public Complex Times (double x) {

    return new Complex(u*x, v*x);
    
  }</code></pre>

<p>Here's a simple test program for your new method:</p>

<pre><code>
class RealComplex  {

  public static void main (String args[]) {
  
    Complex v, z;
    double x = 5.1;


    v = new Complex(3,-4.5);
    System.out.println("v: " + v);
    System.out.println("x: " + x);


    z=v.Times(x);
    System.out.println("v * x: " + z);


  }
  
}
</code></pre>


<p>The astute among you may be saying to hold on here, we've redefined the 
Times method.  Now how can we multiply two complex numbers?
However there's really no problem.  The compiler notices
that the arguments of the two methods named Times (not the same as the
arguments of the two complex numbers but unfortunately the terminology
fails us here) are different.  One multiplies two complex numbers, the other
multiplies a real number and a complex number.  The compiler is smart enough
to figure out which version of Times to use when.  This is called
<dfn>method overloading</dfn> or <dfn>polymorphism</dfn>.</p>

<p>In some object-oriented languages like C++ you can not only overload
methods but even operators like + and =.  However while this makes 
 numeric classes like complex numbers easier to work with, it tends to lead to 
unreadable and unmaintainable code for non-numeric classes.  Therefore Java's
designers elected not to add this feature to the language. As you can see from our
example, with a little forethought you really don't lose very much without
operator overloading.</p><p> 

</p><h6>Exercises</h6>
<ol>
<li>Add a method to the Complex class 
that adds a real number to a complex number and returns a complex number.
</li><li>Add methods for subtracting a real number from a complex number
 and for subtracting a complex number from a real.  Be careful since 
subtraction, unlike addition, is not commutative.
</li><li>Add methods for dividing a real by a complex number and for dividing a complex number
by a real.  Be careful since division, unlike multiplication, is not commutative.
</li></ol>

<h3><a name="xtocid1903648">Scope: Calling the Complex Class From External Classes</a></h3>

<p>Until now we've stored almost every program in a single file.
This becomes unwieldy as programs grow large. It becomes impossible to manage
when more than one person is working on a program.  It also loses out on one of
the key benefits of OOP, code reusability.  As long as all the code for
a program is stored in one file, you can't reuse code except by cut and paste,
just like in a non-object oriented language.</p>

<p>There has been some code that hasn't resided in our
source files.  Remember all those import statements at the
top of every file?  What they do is pull in prewritten and
precompiled code from various locations so we can use it in
our programs. You can do the same thing with classes you
write.  However to do this you do need to be aware of
several conventions and restrictions.  </p>

<ol>
<li>No file should contain more than one public class.  
This means that our Hello World, Goodbye World example 
is no longer valid because each of the classes was public.

</li><li>All files should have the same name as their single public class followed
by the extension ".java".

</li><li>Source code files should be stored in the same directory as their compiled .class
file.  This is so the Java compiler can find the appropriate definitions and interfaces
for a class when the class is referred to in a different file.

</li><li>Source code and .class files should be in a directory 
that's part of the $CLASSPATH environment variable.
</li></ol>

We'll demonstrate this by splitting the example of the
previous sections into two separate files, each of which
contains one class.  Begin by creating a file that contains
the Complex class. (Your complex file may be a little
different depending on how you answered the exercises in the
previous sections.) Save this file as Complex.java.<p></p>

<p>Next save the examples from the previous exercises in a separate file 
called ComplexExamples.java in the same directory as Complex.java.
Now compile both files and run Complex Examples.java.</p>

<h3><a name="xtocid1903649">The Mandelbrot Set</a></h3>


<p>The Mandelbrot set is a classic application of complex arithmetic.
It is <em>the</em> example of a fractal set. </p>

<p>Here and in the future we are going to try to separate the 
mathematical
definition of our data from its display on the screen.  In fact we
won't even add the screen display till the second iteration of the program.</p>

<p>Our data structure will be a two dimensional array,
each element of which represents a fixed point in the complex plane.
The array is defined by the value of the lower left point, the gap between
points and the number of pixels in the x and y directions.  Thus
given that element (0,0) of the array matches the complex
point (x0,y0), each point
is separated by a value <i>gap</i>, 
we know that element i,j of the array
represents the point (x0 + i*gap, y0 + j*gap) in the complex plane.
Since we know this by position of the array element alone
we dont' need to store this value in the array.</p>

<p>What will we store in each element of this array?  We'll calculate
a number to go there in the following fashion.  Let z = 0 + 0i and
let c be the position of that array element in complex space.
calculate z = z*z + c and iterate as follows up to 200 times:</p>

<pre><code>for (i=0; i &lt; 200; i++)  {
  z = z.Times(z) + c;
}</code></pre>

<p>The Mandelbrot set is composed of those elements which, no matter
how long we do this, never approach infinity.  Since infinity can take
a mighty long time to approach, it's fortunate that a fairly elementary theorem
in complex variable theory guarantees that any number whose magnitude
ever exceeds two in this iterative scheme will become as large
as one might wish.  (i.e. They asymptotically approach infinity.)
Therefore once a number exceeds two we can break out of the loop and
say definitively that this number is <em>not</em> in the Mandelbrot set.</p>

<p>Unfortunately there's no guarantee that just because an element 
doesn't reach 2 in two hundred iterations it might not reach 
 two on the two hundredth and first iteration or the two thousandth
or the two millionth.  However most numbers that don't prove they're
not in the Mandelbrot Set by the two hundredth iteration are
reasonably likely to be in it.</p>

<p>Here's how the code will work.  First we'll select the lower left
hand corner of our rectangle in complex space, the size of the gap 
between the points and the number of points in each dimension.
For a specific example we can choose the square bordered on
the lower left by (-2,-2) and on the upper right by (2,2).
To keep initial computations manageable we'll break this up into
an array of 101 by 101 elements which implies a gap size of
0.05.</p>

<p>Once this array is created we'll loop through it and fill each 
element with a Boolean value, true if the element is probably in the Mandelbrot Set
(doesn't pass two in two hundred iterations) and false if it's not (does 
pass two and thus go to infinity).
Here's the code:</p>

<pre><code>
class MandelApp {

  public static void main(String args[]) {

    int xdim = 101;
    int ydim = 101;
    double xstart = -2.0;
    double ystart = -2.0;
    boolean Mandel[][] = new boolean[xdim][ydim];
    double gap = 0.05;
    int max_iterations = 200;
    int i,j,k;
    Complex z, c;

    for (i=0; i &lt; xdim; i++) {
      for (j=0; j &lt; ydim; j++) {

        c = new Complex(xstart + i*gap ,ystart + j*gap);
        z = new Complex(0.0, 0.0);
        k=0;
        while (z.Magnitude() &lt; 2.0 &amp;&amp; k &lt; max_iterations) {
          z = z.Times(z);
          z = z.Plus(c);
          k++;
        }
        if (z.Magnitude() &lt; 2.0) {
          Mandel[i][j] = true;
        }
        else Mandel[i][j] = false;
      }
    }
  
  }
}</code></pre>

<h5>Drawing the Mandelbrot Set</h5>


<p>To make this interesting we want to actually draw pictures of the
Mandelbrot Set.  To do this we'll move the actual calculation into
a thread in an applet and then draw the results into a bitmap.  Here's the code:</p>

<pre><code>import java.applet.Applet;
import java.awt.*;

public class Mandelbrot extends Applet {

  int xdim;
  int ydim;
  double xstart = -2.0;
  double ystart = -1.25;
  int Mandel[][];
  double gap = 0.05;
  int max_iterations = 256;

  
  public void paint(Graphics g) {
  
    int i,j,k;
    Complex z, c;
    
    xdim = size().width;
    ydim = size().height;
    gap = 2.5/ydim;
    Mandel = new int[xdim][ydim];
    
    for (i=0; i &lt; xdim; i++) {
      for (j=0; j &lt; ydim; j++) {
        c = new Complex(xstart + i*gap, ystart + j*gap);
        z = new Complex(0.0, 0.0);
        for (k = 0; z.Magnitude() &lt; 2.0 &amp;&amp; k &lt; max_iterations; k++) {
          z = z.Times(z);
          z = z.Plus(c);
        }
        g.setColor(selectColor(k));
        g.fillRect(i, j, 1, 1);
      }
    }
  
  
  }
  
  
  protected Color selectColor (int num_iterations) {
  
    if (num_iterations &gt; max_iterations) return Color.black;
    else if (num_iterations &gt; 9*max_iterations/10) return Color.darkGray;
    else if (num_iterations &gt; 8*max_iterations/10) return Color.gray;
    else if (num_iterations &gt; 7*max_iterations/10) return Color.magenta;
    else if (num_iterations &gt; 6*max_iterations/10) return Color.cyan;
    else if (num_iterations &gt; 5*max_iterations/10) return Color.blue;
    else if (num_iterations &gt; 4*max_iterations/10) return Color.green;
    else if (num_iterations &gt; 3*max_iterations/10) return Color.yellow;
    else if (num_iterations &gt; 2*max_iterations/10) return Color.orange;
    else if (num_iterations &gt; 1*max_iterations/10) return Color.red;
    else return Color.white;
  
  }

}</code></pre>

<p>This program is minimal. It should really create an <code>ImageProducer</code> which draws the 
Mandelbrot set. There are also a lot of additions that could be made to the parameters
to allow for zooming in on particular regions. In fact you could even implement this 
as a <code>Canvas</code> in an applet with various controls to select the area of interest.
This will all be investigated in the Cafe Au Lait newsletter.</p>

<p>For more details on the Mandelbrot Set see the first chapter
of <person>A.K. Dewdney's</person> <cite>The Armchair Universe</cite>.
</p>

<h6>Exercises</h6>
<ol>
<li>Explore different starting points and gap sizes
for the Mandelbrot set.  To make this easier add user
input to dynamically select the starting point and gap size.</li>
<li> What happens if you allow the x and y gap size to be chosen independently?
</li>
</ol>

<h2><a name="xtocid459773">Acknowledgements</a></h2>

<p>Noone ever truly writes a book alone.  This tutorial
relies heavily on <person>Brian Kernighan</person> and <person>Dennis Ritchie's</person>
<cite><a href="http://www.amazon.com/exec/obidos/ISBN=0131103628/ref=nosim/cafeaulaitA/">The C Programming Language</a></cite>, one of the alltime classics
of computer language manuals.</p>

<p>The presentations at the first Java Day in New York City
were crucial to getting my understanding of Java off the
ground, especially those of <person>Bill Joy</person> and
<person>Frank Greco</person>.</p>

<p>The eventtutor applet, flying lines applet and Mondrian
applets are taken in spirit if not in code from <person>Dave
Mark</person> and <person>Cartwright Reed's</person>
<cite>Macintosh Programming Primer</cite>.</p>

<p>Finally I'd like to thank <person>Olivia Whiteman</person>,
<person>Dave Fisco</person>, <person>Tim Arnold</person> and
all the other Java Invaders for putting together forums in
which I could learn more Java.</p>

<p></p><hr>
<div style="text-align: center;">[ <a href="http://www.cafeaulait.org/">Cafe Au Lait</a> | <a href="http://www.cafeaulait.org/books.html">Books</a> | <a href="http://www.cafeaulait.org/tradeshows.html">Trade Shows</a> |
 <a href="http://www.cafeaulait.org/javafaq.html">FAQ</a> | <a href="http://www.cafeaulait.org/javatutorial.html">Tutorial</a> | <a href="http://www.cafeaulait.org/usergroups.html">User Groups</a> ]</div>
<hr>
Copyright 1995-1998, 2000-2002, 2004-2006 <a href="http://www.elharo.com/"><au>Elliotte Rusty Harold</au></a> <br>
<a href="mailto:elharo%40metalab%2Eunc%2Eedu">elharo@metalab.unc.edu</a><br>
 Last Modified June 3, 2006

</li></body></html>